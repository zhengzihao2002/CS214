CS 214 / 2022-01-24
===================


Using the compiler (gcc)

$ gcc -c source.c
	-> compiles but does not link
	-> creates "relocatable object" file source.o
	
$ gcc source.c
	-> compiles and links
	-> creates executable file a.out
	
$ gcc source.o
	-> links
	-> creates executable file a.out

options
	-o file
		give a specific name for your output file
	
	-Wall
		turns on warnings
	
	-Werror
		treat warnings as error
	
	-std=c99
	-std=c90
		require a specific version of C

How do command-line programs work with files?
-> "working directory"
	-> where you "are"
	-> file names refer to files in the working directory
	
	$ pwd
		-> prints working directory
	$ cd some_directory
		-> change working directory
	$ cd
		-> changes to your home directory
	$ cd -
		-> changes to your previous directory / goes "back"
	$ cd ..
		-> changes to the parent of the current directory
	$ ls
		lists files in the working directory
	$ ls path/to/directory
		lists files in the specified directory


Variables
---------

What are variables in C?
	variables are names for "objects"
		an object (in this context) is any data that is stored in memory
			that has a persistent identity
		a box that we can store data in
		usually associated with a type

int x;
	-> tells compiler to create an object that can store an int
	-> compiler keeps track of where it is and how to access it
	-> compiler will allocate and deallocate space as needed
	
	when we refer to x, we either refer to the data stored in the object
		or the location itself
		
		x = x + 1;
			<- on the right side, "x" means the data (integer) stored in x
			<- on the left side, "x" means the location of x (or the object)

		1. read the value of x
		2. compute x + 1
		3. store the computed result in x

		other languages might write assignment like so:
			x := x + 1;
			x <- x + 1;

global variables are declared outside any function (top-level)
	allocated when program begins
	deallocated when program terminates
local variable are declared within a function
	allocated when the function begins
	deallocated when the function ends

	int global;   // global variable

	void function(int argument)   // local variable
	{
		int local;
		...
	}


Scoping
	every variable is associated with a scope
		essentially, the meaning of the variable is only defined within that scope
		we cannot refer to a variable outside its scope

	scopes in C are nested
		we can refer to global variables inside a function
		
	
	int global = 0;
	void function(int argument)
	{
		global += argument;
			// global is visible here, because the local scope does not declare any variable
			// by that name
	}

	shadowing occurs when a local variable has the same name as a global variable
		(more precisely: an inner scope reuses a name from an outer scope)

	int foo = 1;
	void function(void)
	{
		int foo = 2;   // local foo "shadows" the global foo
					   // in fact, we have no way to refer to the global foo inside this function!
					   
		printf("%d\n", foo);   // this will print 2
	}

	int main()
	{
		function();
		printf("%d\n", foo);  // this will print 1
		
		return 0;
	}
	
	any compound statement can introduce a nested scope
	
	void fun(void) {
		int foo = 1;
		
		if (...) {
			int foo = 2;   // local to the body of this if statement
			               // shadows the foo declared outside the if statement
			
			int bar = 3;   // local to the body of the if statement
		}
		
		printf("%d\n", foo);  // this will print 1
		
			// bar cannot be referred to here (not in scope)
	}


shadowing variables is not usually useful to do, and can be confusing

every variable has:	
	a type (says how big the object is and how to interpret its contents)
	a lifetime (says when the object is created and destroyed)
	a scope (says where the name has meaning)

it is common to talk about variables and their associated objects as though they were the same,
	but keep the distinction in the back of your mind
	
	-> not all objects are associated with variables! (more on this later)

Arrays
------

An array variable is created by including a dimension with a variable name

	int A[10];    // declares A as an array of 10 integers
		note that the dimension is put on the name, not the type
		array variables always refer to a specific array
			-> they cannot be reassigned
			-> the array size cannot be changed
			-> the array size is not available at run-time
				(that is, A.length is not a thing)
		the dimensions must be known at compile time
			(* variable length arrays were added in C1999, but removed in C2011)
			
			int n;
			int A[n];   // variable-length array; do not use
				// -Wvla will warn if you use a variable-length array
		
		
			// in Java,
			int[] A = new int[10];

	array variables can only be used for fixed-size arrays of known length
		-> use dynamic allocation for more flexible arrays (malloc(), more on this later)

array variables are stored in the same way as other variables

	global arrays are stored in the global data section
	local arrays are stored in the stack


How do we get the length of an array?
	We can't
	Instead, we need to remember how big it was when we created it

Arrays are passed by reference

	int foo(int x[], int n)     // we use [] because x has no specific length
	                            // note that we had to pass the length explicitly
	{
		int i, total = 0;
		for (i = 0; i < n; ++i) {
			total += x[i];
		}
		
		return total;
	}


Using #define to specify array length

	#define VECTOR_LENGTH 10
		// this is a "pre-processor macro" (not a variable! is not stored anywhere!)
		// before we compile, "VECTOR_LENGTH" will be replaced with "10" in our source code
		//  (not inside strings)
		// macro names are usually all-caps, but this is not required
	
	// argument must be array of length VECTOR_LENGTH
	void zero_out(double V[])
		// don't need to specify length, because we should only call with arrays of the correct length
	{
		int i, total = 0;
		for (i = 0; i < VECTOR_LENGTH; ++i) {
			V[i] = 0;
		}
	}
	
	int main()
	{
		int V1[VECTOR_LENGTH], V2[VECTOR_LENGTH];
		
		...
		
		zero_out(V1);
			// within zero_out, V will refer to the same object as V1
			// so this sets all the array elements of V1 to 0
		
	}

Accessing array elements
	put index in square brackets
	
	int foo[20];
		// array indices are 0 .. 19
	
	foo[0] = 1;
			// left side refers to first element of foo
	foo[1] = foo[0];
			// left side refers to second element of foo
			// right side refers to (value of) first element of foo

note: because array length is not kept at run-time, there is no bounds checking

	foo[20];  // technically valid code, but the value is undefined
		// if we are lucky, the compiler will notice and complain
		// if we are lucky, we will get a run-time error/crash
		// most of the time, nothing obviously wrong will happen
		// ... until that time you overwrite something in memory and your program does something bad
		// this is the "buffer overflow" you hear about in security patches
 
 	foo[-1]  // also not forbidden, but generally never a good idea
 
	Use AddressSanitizer to check for run-time memory errors like this
		Add -fsanitize=address to your compiler command

Initializing arrays
	in C, local variables are not initialized by default (they contain unspecified "garbage" data)
	
	int i;      // value of i is not determined (difference from Java)
	int j = 0;  // initialize j to 0
		// you might as well always initialize your variables to avoid non-deterministic behavior

	use curly braces to initialize arrays
	
	int A[3] = {1, 2, 3};  // initialize the three elements of A
		
		-> this is only for initialization; there are no "array literals"
	
	variants:
	implicit dimension
			int A[] = {1, 2, 3};   // dimension implicitly 3
	
	partial initialization
			int A[10] = {1, 2, 3};  // first 3 elements initialized, remaining 7 uninitialized

	if we want to zero out an array, we can use memset()
	
	int A[20];
	memset(A, 0, 20 * sizeof(int)); 
		//note that we have to give the size in bytes (array length * size of array element)
		//we can use other byte values, if we want
		// we can't use memset() to initialize to specific integers, unfortunately



takeaways:
	objects are boxes in memory that we can store data in
		objects have a lifetime (when they are created/destroyed)
		objects have a size (implicit)
	variables are names that let us refer to certain objects
		variables have a scope (within a scope, a variable refers to a specific object)
		-> in functions, each call gets its own scope
		-> e.g., each call in a recursive function gets its own objects


How to print an integer:

	#include <stdio.h>
	
	printf("format string", values ....)
	
	format codes
		%d  <- decimal integer
		%f  <- floating point
		%s  <- string
		%c  <- char
	
	int i;
	printf("%d\n", i);   // print the value of i
	
	// format strings can include arbitrary text
	printf("The value of i is %d! Isn't that nice?\n", i);
 
CS 214 / 2022-01-26
===================


Terminology
-----------

static/dynamic

	static properties of a program are always the same
		- they do not depend on anything that happens when the program is running
		- can be determined just by looking at the source code
		- static analysis gives us the information you can obtain just from the source code
			- type correctness
			- number of variables
			- number of functions
	
	dynamic properties can depend on run-time events
		- they can be different each time the program runs
			- they can be mutable or immutable
		- dynamic analysis requires a simulation of program behavior

program/process

	a program is your code (compiled or source code) - always static
	a process is a program that is being run
		program + run-time state (values in variables, active functions, etc.)
	
	program is static
	process is dynamic

declaration/definition/initialization

	a declaration says that something (variable, function, etc.)
	a definition says what it is
		every definition is implicitly a declaration
	
	variable definitions can optionally initialize the variable
	
	int n;      // defines (and declares) a variable, but does not initialize it
	int n = 1;  // defines and initializes a variable
	


	// defines the function foo()
int foo(int x) {
	return x;
}

int foo(int);
	// function prototype
	// this declares foo(), but does not define it

why would we want to declare something without defining it?
	- we cannot refer to something unless it has been declared
		- in C, declarations must occur earlier in the file than references
		
		
		void foo(unsigned int x) {
			if (x > 0) bar(x - 1);   // problem! bar() is not declared
		}
		
		void bar(unsigned int x) {
			if (x > 0) foo(x - 1);
		}

	solution:

		void bar(unsigned int);   // declares bar()

		void foo(unsigned int x) {
			if (x > 0) bar(x - 1);
		}
		
		void bar(unsigned int x) {
			if (x > 0) foo(x - 1);
		}

Header files (*.h)

	typically just contains declarations
		function prototypes
		global variable declarations
		type declarations or definitions
		
	
	mutual.h:
	
		void foo(unsigned int);
		void bar(unsigned int);
	
	mutual.c:
		
		#include "mutual.h"

		void foo(unsigned int x) {
			if (x > 0) bar(x - 1);
		}
		
		void bar(unsigned int x) {
			if (x > 0) foo(x - 1);
		}
	
	other.c:
	
		#include "mutual.h"
		
		int main(int argc, char **argv)
		{
			foo(5);
			...
		}
		
	note that other.c includes the declarations but not the definitions
	this is so we can link mutual.o and other.o later on
	
	$ gcc -c other.c
		-> creates other.o
		-> other.o contains unresolved references (foo)
	
	$ gcc other.o mutual.o
		-> links our compiled files
		-> resolves references (connects foo in other.o to foo in mutual.o)

	$ gcc mutual.c other.c
		-> compile and link everything all at once
		-> but why bother with separate files?

How this works with global variables

	int glob;   // defines a global variable (and implicitly initializes it to 0)
	
problem: you can't define something more than once
	how can we have a global variable be referenced in more than one file?

solution: use "extern" to declare a global variable

	extern int glob;  // declares (but does not define) a global variable
	
		// extern is not a type

Global variables are usually not good design, but if you need to refer to a global variable
in multiple files, extern is there for you


Type definitions (more on those later) can be repeated, so it is okay to have them
in multiple places



Control structures
------------------

C supports "structured" programming
	i.e., it has syntax for if-statements and loops and functions
	
C control structure syntax is basically the same as Java

function definitions:

	return_type function_name(arg_type arg_name, ... )
	{
		statement;
		statement;
		...
	}


	functions that do not return value have "void" return types
	
	void do_something(int x)
	{
		if (x < 0) return;
		
		printf("%d\n", x + 1);
	}
	
		return keyword is optional, but should not be used with a value


	functions that do return values must include return
	
	int triple(int x)
	{
		return x * 3;
	}


conditionals

	if (expression) statement
	else statement
	
		"statement" can be a single statement (terminated by a ;) or a compound statement (using { and } )
		
		
	if (x > 0) puts("Positive");
	else puts("Negative");
		
		// else is optional
	
	if (x > 0) {
		puts("Positive");
	} else {
		puts("Negative");
	}
	
	if (x == 0) {
		puts("Zero");
	} else if (x > 0) {
		puts("Positive");
	} else {
		puts("Negative");
	}
	
	The expression is treated as a Boolean, but remember that C has no bool type
		we typically use int for bool
			0 is false
			non-0 is true
		
		whenever we write something like
			if (b) ...
			
		that is the same as writing
			if (b != 0) ...
		
	
	
	switch (expression) { switch_body }
	
		switch is used for non-binary choices
		useful if we have a small set of discrete cases (e.g., integers)
		
	
	char cmd;
	....
	switch (cmd) {
		case 'N':
			go_north();
			break;
		
		case 'S':
			go_south();
			break;
		
		case 'E':
			go_east();
			break;
		
		case 'W':
			go_west();
			break;
		
		default:
			bad_direction();
	}
	
	switch only works with integers and integer-like values (chars and enums)
	case labels must be static (constants or literals)
		-> they cannot be variables (even const variables)
		
	once we do the jump, case labels are no longer considered
		-> by default, we "fall through" to the next case
		-> to avoid fall through, use break
		
		why is this a feature?
			it allows us to put multiple labels on the same branch
		
		
		case (condition) {
			case good:
			case okay:
				puts("Everything is fine!");
				break;
			
			case bad:
				puts("Oh no!");
				oh_noes++;
				break;
			
			default:
				bad_condition();
		}
	
	-> we can't use variables as case labels, so how is the above allowed?
	
	We could have used #define
	
		#define bad 0
		#define okay 1
		#define good 2
	
	Or, we could use an enumerated type
	
	enum condition_t { bad, okay, good };
	
		-> defines a type called "enum condition_t"
		-> defines three values: bad, okay, and good
	
	enums are just fancy integers
		each enumerated value is assigned a numeric value (by default, in order starting with 0)
	
	defining a variable with enum type
	
	enum condition_t condition;		// requires "enum condition_t" to be previously defined
	
	
	we can also define the type and a variable at the same time, if we really wanted to
	
	enum { bad, good, okay } condition;  // weird to do
	
	enums and switch are perfect together!
	
		names for the "enumerators" must be unique
		
		enum foo { baz, quux };
		enum bar { baz, foobar };
			// not allowed, because baz can only be in one enum
	
	
	-> look up "Duff's device" if you want to see really clever/impressive/awful use of switch
	
Loops:
	C has three loops (same ones as C++, Java, etc.)
	
	
		while (condition) body
			-> run body 0 or more times
		do body while (condition);
			-> run body 1 or more times
		for (init; condition; advance) body
			-> fancy while loop
				init runs before the loop
				condition is checked to decide whether to run the body
				advance is run after the body

		"body" can be a single statement (ends with ;) or a compound statement (using { and })
		
		while (x > 1) if (x % 2 == 0) x = x / 2; else x = x * 3 + 1;
			// technically valid, but not particularly readable
		
		// equivalent, but better style
		while (x > 1) {
			if (x % 2 == 0) {
				x = x / 2;
			} else {
				x = x * 3 + 1;
			}
		}

	i = 0;
	while (i < N) {
		printf("%d\n", vector[i]);
		++i;
	}
	
	for (i = 0; i < N; ++i) {
		printf("%d\n", vector[i]);
	}
	
	prior to C-1999, the initializer of a for loop had to be an expression
		C99 and later allow variable definitions in the initializer
	
		for (int i = 0; i < N; ++i) {
			...
		}
	
goto:
	it exists
	
	you can put "label:" in front of any statement in C
		you can use that label as the target of a goto
		aside from marking a target, labels do not do anything

	goto is not generally recommended
		a few specialized uses are okay, but feel free to never use them

	...
	{
		int fd = open(...);
		if (fd == 0) goto error;
		
		... code for the working case ...
		
		clean_up();
		return;
		
	error:
		puts("Something went wrong!");
		clean_up();
	}
		
	
	}
	
 
CS 214 / 2022-01-31
===================


Recap: Control Structures
-------------------------

Functions
	- all code lives in a function
	- every program must contain a function called main()

Conditionals
	- if, if else
	- switch

Loops
	- while
	- do while
	- for
	
		for (i = 0; i < n; i++) {
			// body
		}
		
		for (i = 0; i < cols; i++) {
			for (j = 0; j < rows; j++) {
				dest[i][j] = src[j][i];
			}
		}


		for (col = 0; col < cols; col++) {
			for (row = 0; row < rows; row++) {
				dest[row][col] = src[col][row];
			}
		}

Recap: Objects in memory
------------------------

by "object", I mean a container in memory that we can store data in
	every variable is associated with an object
	objects have an identity
		- this is distinct from the value stored in the object
		- this allows us to talk about objects that change values over the course of a program

Conceptually, an object has
	a location in memory
		one or more bytes in memory used for storage (contiguous)
		this location will have an address
	a size (in bytes)
	a type (influences how we interpret the data)

	- these are static (do not change over the lifetime of the object)

objects have three kinds of lifetime

- some objects are created when the process begins and live until the process terminates
	- e.g., global variables, functions, string literals
	- these are stored together in memory (the "global" space)

- some objects are associated with a function
	- allocated when function is called, deallocated when function returns
	- local variables, function-specific information
	- these are stored in "the stack"
	- automatically managed

- some objects have no defined lifetime
	- allocated when needed, deallocated when no longer needed
	- these are stored in "the heap"
		- so called because it is a disorganized pile of stuff
		- no connection to the data structure called a heap
	- in Java, "new" creates objects in the heap
		- Java has garbage collecting, which deallocates objects that are no longer needed
	- in C, we must explicitly allocate and deallocate heap objects
		- malloc(), free()


- objects can be made of smaller objects (e.g., arrays and structs)


Pointers, addresses, pointer variables
--------------------------------------

What is a pointer?
	- usually people mean an address (usually an integer)
		- in C, it will have a pointer type	that indicates what sort of data it points to

pointer type syntax is a little weird
	
	int *p;
		p is a pointer variable (it stores an address)
		the data p points to should be an integer


		int* p;  // also ok, but be careful
		
		int *p, *q; // declares two pointers, p and q
		
		int* p, q;  // declares one pointer, p, and an integer, q

How do I assign to my pointer variables?
	- we can obtain the address of a variable
	- we can get an address from a function


	int n;  // declares an integer variable
	
		&n   <- this is the address of n

	p = &n;  // assign the address of n to p

		there are now two objects associated with p
		
		- the object for p itself
		- the object that p points to
		
		*p   <- "dereferences" p
	
			instead of talking about p, talk about the object p points to

		after p = &n, *p and n refer to the same object
		
		n = 5;
		printf("%d\n", *p);   // will print 5
		
		*p = 6;
		printf("%d\n", n);   // will print 6


		&*p is the same as p

	&p is the address of p itself (not the address that p contains)

	int **q;
	q = &p;


recall array variables

	char a[] = {'a', 'b', 'c'};

	what is a?
	
		an array variable is associated with an array object (in the global space or the stack)
		the address of an array is the same as the address of its first element (index 0)


	these are effectively all the same (all are the address of index 0)
		a
		&a
		&a[0]



	*a = 'Q';
	// strange way of writing a[0] = 'Q';


	char *p;
	
	p = a;
		// p and a both refer to the same object (sort of)

	p[0] = 'Q';  
	*p = 'Q';
	
	what happens here?

	p = &a[1];
	*p = 'R';   

	this is fine (same as a[1] = 'R')
	
	p[1] = 'S';
		same as a[2] = 'S';


	p[-1] = 'P';   // ????!

		same as a[0] = 'P';
		believe it or not!



pointer arithmetic
	we can add and subtract integers from pointers
	
	if I have int *p
		p is the address of an integer
		p + 1 is the "next integer" in memory
		
	we basically assume we have a pointer to the middle of an array
		adding 1 gives us the address of the next array element
		subtracting 1 gives us the address of the previous array element



	int length = 0;
	char *p;
	for (p = some_string; *p != '\0'; p++) {
		++length;
	}

what is array access?

	a[i] is the same as *(a + i)
	&a[i] is the same as a + i

int mat[ROWS][COLS];
	mat is an array of arrays of ints

	mat     the entire matrix
	mat[0]  the first row
	mat[0][0]   the first column of the first row
	
		mat + i    same as &mat[i]
	
		the compiler can skip ahead the appropriate amount because the type of mat includes the dimensions
		
	mat[i][j]  
		*(*(mat + i) + j)

sizeof()
	sizeof(int)   the "sizeof operator"
		we can use it with a type
		
	sizeof(mat[i][j])
		we can use it with a variable (or any object reference)


	sizeof(mat)
		the compiler knows how big an array variable is, so it will compute the size of the array
		sizeof(int) * ROWS * COLS
		
		
int *m = mat;    // same as m = &mat[0][0]

	what is sizeof(m)?
		same as sizeof(int *)


char a[] = "hello";
char *p = "hello";

	a and p both refer to a string of six characters in memory

	when we initialize an array variable, we copy the data into the object
	when we initialize a pointer variable, we store the address in the object


	a[0] = 'H';
		a[-1]  // buffer overflow
		a[6]   // buffer overflow

	p[0] = 'H';
		will probably crash your program
		p points to a string literal, which is in a read-only portion of memory


char a2[100] = "hello";



int *p = "yes";
...

p = "no";    // pointers can point to different things over their lifetime


Heap allocation
---------------

How do I get objects on the heap?


	objects on the heap are not associated with a variable
	
	we create them using malloc()
	
	void *malloc(size_t);
	
	
	int *p = malloc(5 * sizeof(int));
	
	
	int *p;
	p = malloc(5 * sizeof(int));
	
	
	p[0] = 1;
	p[1] = 2;
	
	
	when we are done with the array, we use free() to deallocate it
	
	free(p);
	
	
	it is good practice to free any data you allocate
 
CS 214 / 2022-02-02
===================

More global variables
---------------------

we have two kinds of variable in C: global variables and local variables

	global variables have static lifetime and 
		global scope (everywhere in a file after their declaration)
	
	local variables have lifetimes tied to specific functions
		local scope (only within a specific function, or block within a function)
		
exceptions:

	static local variables
		static int i;
			- local scope
			- static lifetime
			
	
	// returns a bigger number each time it is called
	int count(void)
	{
		static int i = 0;  // static initialization happens 1 time, when process begins
		return i++;
	}
	
	strtok()


	static global variables
	
	recall linking (combining multiple compiled files into a single executable)
		-> linking connects names ("symbols")
			things that I declare in one file, but define in another

	by default, global variables and functions have "link wide" visibility
		all declarations refer to the same object
		no other object can have the same name
		
	putting static in front of a global variable or function makes it have "file wide" visibility
		does not get linked with declarations in other files




Direct and indirect references
------------------------------

A variable name is a "direct reference" to an object

Pointers give us "indirect references"

	int x;
	int *p = &x;
		
		x directly refers to an int object
		p directly refers to a pointer object
			it indirectly refers to the same int object as x

	in an expression:
		p   bare references are direct references
		*p  the unary star gives us an indirect reference

	int **q;
	q = &p;

	*q refers to the same object as p
	**q refers to the same object as x



int *p = &x;  // when you initialize a pointer variable, you provide an address
*p = x;    // not the same as assigning to *p
p = &x;


	int *q = &p;  // type error: q needs int *, but &p is int **


type var = value;

type var;
var = value;


Dynamic allocation
------------------

create objects that are not directly referred to by any variable
	- size and number of objects not statically determined

C standard library includes to functions that manage the heap
	malloc()  - reserves (allocates) a portion of the heap, returns a pointer to it
	free()    - deallocates a portion of the heap
	
int *make_array(int length)
{
	int *p = malloc(length * sizeof(int));
	
	if (p == NULL) { explode or something }
	
	return p;
}


	void *  malloc(size_t);
	
	void * is a generic pointer (does not say what kind of data it points to)

		C automatically casts void * to and from specific pointer types



C lets you freely cast pointers

	int x = 5;
	float *p;
	
	p = (float *) &x;   // cast int * to float *
		// C does not mandate exactly what you get here
		// but p will point to the same bytes as x

	p = &x;   // not allowed: cast does not happen automatically


	void free(void *);
		
		- free() accepts a pointer of any type
		- must only be given pointers that were obtained from malloc()
			- that have not already been freed


allowed

	int *p, *q;
	
	p = (int *) malloc( 100  * sizeof(int)) ;
	q = &p[0];
	
	free(q);


not allowed

	int *p, *q;
	
	p = (int *) malloc(100 * sizeof(int));
	q = p + 1;
	
	free(q);


dangling pointers
	- an indirect reference to an object that no longer exists

garbage pointers
	- pointer that does not refer to any specific object


int *p = (int *) 5000;   // useful on embedded systems, some OS writing
	// highly specialized!
	
int *p = NULL;
	// constant pointer
	// by definition, NULL does not point to anything
	
	// NULL is usually 0, but we shouldn't assume it is
	// NULL is false
	
	int *p; 
	
	..
	if (p) {
		// only reached if p != NULL
	}
	
	same as if (p != NULL)


struct
------

arrays are collections of data that are all the same type, indexed by number
structs are collections of data that are not all the same type, indexed by name

struct some_name {
	field_type field_name;
	field_type field_name;
};


struct point {
	double x;
	double y;
};

struct point origin;
origin.x = 0;
origin.y = 0;

struct point origin = {0, 0};


double distance(struct point p, struct point q)
{
	double xdiff = p.x - q.x;
	double ydiff = p.y - q.y;
	return sqrt(xdiff * xdiff + ydiff * ydiff);
}

void move(struct point p)
{
	p.x += 10;  // useless: p is a copy of the argument, not the same point object
}

void actually_move(struct point *p)
{
	p->x += 10;
	
	// same as: (*p).x += 10;
}



struct node {
	int data;
	struct node *next;
};

int find(int val, struct node *head)
{
	struct node *p;
	
	for (p = head; p != NULL; p = p->next) {
		if (p->data == val) return 1;
	}
		
	return 0;
}



	struct node *head = malloc(sizeof(struct node));
	head->data = 0;
	head->next = NULL;
	

struct rectangle {
	struct point topleft;    // direct reference to a point
	struct point bottomright;
};
	
struct rectangle r;
 
 r.topleft.x = 1;
 

struct rectangle r2 = { { 1, 2}, {3, 4} };
struct rectangle r3 = { 1, 2, 3, 4};
struct rectangle r4 = { {1, 2}, 3, 4 };
	// all allowed, but r2 is probably best
	// (-Wall will give warnings about r3 and r4)
 
void print_rect(struct rectangle *r)
{
	printf("(%f,%f)-(%f,%f)\n", r->topleft.x, r->topleft.y,
		r->bottomright.x, r->bottomright.y);
}

 
struct other_rectangle {
	struct point *tl;   // indirect reference to a point
	struct point *br;
};

struct rectangle r;

	r.topleft = malloc(sizeof(struct point));
	r.topleft->x = 1;

	(*r.topleft).x = 1;


 
void print_other_rect(struct other_rectangle *r)
{
	printf("(%f,%f)-(%f,%f)\n", r->tl->x, r->tl->y,
		r->br->x, r->br->y);
}


-----------------
 



CS 214 / 2022-02-07
===================


char data[sizeof(int)];
int *p;

p = (int*) data;

p and data both point to the same bytes in memory

*p = 0xABCD1234;

data[0] ?
    0x34
    0xAB
    
    -- depends on whether you are a big-endian or little-endian architecture!
    -- also depends on how big an int is (we are assuming 4 bytes)

-- functions that convert between "host order" (big- or little-endian) and
    "network order" (big endian)
    hton()
    ntoh()

struct struct_name {
    type field_name;
    typ2 field2_name;
};

- can be global or local variables (automatically managed)
- can be on the heap (manually managed)
- passed by value to functions (as though we had passed each field individually)
    - typically we pass a pointer to the structure
- can be returned from functions
- can be nested in other structs

union
-----

union union_name {
    type field_name;
    type2 field2_name;
};

a union variable is big enough to story any of the fields
but it only contains one at a time

union int_or_float {
    int i;
    float f;
} fi;

fi.i = 254;  // now fi contains an int

fi.f = 2.5;  // now fi contains a float

unions are "untagged" -- no record is kept of what sort of data is in the union

not especially useful by itself
    these days, we can just use separate variables and not worry about wasted space


what happens if we read the wrong kind of data?

fi.f = 0.5;
printf("%d\n", fi.i);
        // probably we get the integer whose bit representation is the same as 0.5
        // but it is not actually guaranteed what will happen
        // use pointer tricks if you really want this

feel free to never use unions

enum
----

use enum to make a type with a fixed number of specific (named) values

enum enum_name { enum1, enum2, enum3 };

enum color { red, green, blue, yellow };

enum color foreground = red;

enum animal { cat, dog, bird, snake };

enum animal ark[100];

the values are called "enumerators"
    cannot reuse names across different enum types

the run-time representation is integers

    by default, enumerators get integer values in order starting from 0
    
enum foo_t { foo, bar, baz, quux = 20 };



enum tag { int_tag, float_tag };

struct i_or_f {
    enum tag content;
    union {
        int i;
        float f;
    } data;
};

struct i_or_f foo;
foo.content = int_tag;
foo.data.i = 0;


enum animal pet;

switch (pet) {
    cat: 
        ...
        break;
    
    dog:
        ...
        break;
    ...
}


typedef
-------

typedef creates a new name for an existing type

typedef int length_t;
    // declares a type length_t which is the same as int
    
length_t length, width, depth;


    -- can be for documentation (indicate purpose of variable)
    -- does not provide safety (new type names are not new types; no type checking)
    -- can be for ease of changes (e.g., change int to long int consistently)
    
    -- can be used for complicated types
    
typedef double coordinate[4];
    -- coordinate is the same as double[4]

    coordinate event;
    same as: double event[4];

typedef double rotor[4][4];
    // rotor is a 4*4 array of doubles



Function pointers
-----------------

functions exist in memory
    - the "data" is the instructions that make up the function
    - on all modern hardware, function objects are read-only
    
a function pointer is just the address of a function
-> if we have a function pointer, we can call that function

function pointer type specifies number and type of arguments and return type

    a function name by itself is a function pointer
    

return_type (*var_name)(argtype, argtype, ...);


int (*fun_to_call)(int);

    fun_to_call is a pointer variable that points to a function that takes an int and
        returns an int

    
int foo(int x)
{
    ...
    return ...;
}


{
    int (*fun_to_call)(int);
    
    fun_to_call = foo;
        // does not call foo!
        
    int x = fun_to_call(12);
    
    
}

why might we want to use function pointers?

    - generic operations
    - bundle data and operations together
    
    
    
key points
- we can get a pointer to any function
- a function name by itself is not a function call
    - must have the () to call the function
- passing a reference to a function is not itself a call to that function

    qsort(arr, len, size, comparison_fun);
        <- passing a reference to comparison_fun, not calling comparison_fun
        
        
----
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int intcmp(const void *a, const void *b)
{
    int x = *(int *)a;
    int y = *(int *)b;

    if (x < y) return -1;
    if (x == y) return 0;
    return 1;
}

int intcmp2(const void *a, const void *b)
{
    int y = *(int *)a;
    int x = *(int *)b;

    if (x < y) return -1;
    if (x == y) return 0;
    return 1;
}

int main(int argc, char **argv)
{
    int arr[20];
    int i;
    for (i = 0; i < 20; i++) {
        arr[i] = (i * 7) % 20;
    }

    qsort(arr, 20, sizeof(int), intcmp2);

    for (i = 0; i < 20; i++) {
        printf("%d ", arr[i]);
    }
    putchar('\n');



    return EXIT_SUCCESS;
}

----
        
exercises
    write a program using qsort()
    write your own generic sort function



----
// What are the prerequisites of this function?
// Can you use typedef to make the signature more readable?

void *least(void *data, size_t nelems, size_t size, 
    int (*cmp)(const void *, const void *))
{
    char *best = data;     // Why char* here?
    char *crnt = best + size;
    char *stop = best + size * nelems;

    while (crnt != stop) {
        if (cmp(crnt, best) < 0) best = crnt;
        crnt += size;
    }

    return best;
}
----
 
CS 214 / 2022-02-09
===================

Preprocessor directives
-----------------------

#include <standard_header.h>
#include "my_header.h"

typically used to bring in header files
    - function prototypes
    - type definitions
    - macro definitions
    

#define MACRO_NAME definition of macro


    - macro substitution replaces the name with the definition
    - macro name must be a complete token (terminated by whitespace or punctuation)_
    - substitution does not happen in strings
    
    
#define NAME "joe nameguy"

    puts("my name is " NAME);
        <- C will combine adjacent string literals into one string literal




#define MEMSIZE 4096

    MEMSIZE*2
        <- C compilers will automatically replace constant expressions with their value
    
    
#define square(X)  X * X
    this is a bad definition!

    square(n)
    =>
    n * n
    
    square(20)
    =>
    20 * 20
    
    
    square(5 - 1)
    =>
    5 - 1 * 5 - 1
    
    x / square(y)
    =>
    x / y * y
    

#define square(X) ((X) * (X))

    solution: use parentheses
    

#define malloc(p) mymalloc(p, __FILE__, __LINE__)

    parentheses here are not needed,
    but it wouldn't be wrong to include them


#define between(x, y, z)   ((x) < (y) && (y) < (z))

    if (between(0,w,20)) { ... }
    
    
    
__FILE__
    <- gets replaced by a string literal that is the name of the file where it occurs
__LINE__
    <- gets replaced by an integer literal that is the line number where it appeared


if a macro occurs in a macro definition, it is expanded after substitution

#define cube(X) ((X) * square(X))



square(square(23)) 

 use backslash to continue the definition on multiple lines
 
#define check(p) if ((p) == NULL) { \
    printf("Null pointer at " __FILE__ ":%d\n", __LINE__); \
    exit(EXIT_FAILURE); \
    }
    

int *q;
check(q = malloc(some_size))


        
Conditional compilation

#ifdef SOME_MACRO
#endif

#ifndef SOME_MACRO
#endif

#if <some constant expression>
#endif



common pattern to avoid problems when a header is included more than once
-----
#ifndef _MY_HEADER_H_
#define _MY_HEADER_H_

.... header stuff

#endif
-----


define a macro only if it is not previously defined...

#ifndef DEBUG
#define DEBUG 0
#endif


{
    if (DEBUG) {  
        // if statements with constant tests have no run-time cost
        printf("debug info" ....);
    }
    
}




-- compiler option to add a new (simple) macro definition
gcc -DDEBUG=1

gcc -DDEBUG
    -- defaults to 1


try it out!
 
CS 214 / 2022-02-14

===================


Project I Questions
-------------------

What sort of errors does free() detect?

    - address outside of memory[]
    - address inside memory[] but not the start of a block
    - address inside memory[] at the start of a free block

Distinguishing between this is
    - impossible to do perfectly
    - still useful to make a "best effort"
    - possibly helpful for client debugging
    
What about alignment?
- we are using Intel systems, where alignment is more "nice to have" than
    "need to have"

- real malloc() always gives pointers with maximal alignment (e.g., 16 or 32)

// one way to ensure 8-byte alignment
struct {
    double ignored;
    byte memory[MEMORY_SIZE];   // gets 8-byte alignment by default
} x;


Demo
----

C provides arrays
    - constant time access
    - no memory overhead
    - fixed size
        - size is implicit


We can make our own linked lists
    - dynamically sized collections
    - more overhead (pointers)
    - can introduce memory fragmentation
    - poor locality
    
    
What about ArrayList?
    - compact, good locality (like an array)
    - can grow and shrink (like a linked list)

C does not provide one
    ... but we can make it ourselves

notes
    - distinguish length of list and capacity of array

typdef ...  arraylist_t;

typedef struct {
    void *data;       // may change as list grows 
    size_t length;    // amount of array currently in use
    size_t capacity;  // may change as list grows
    size_t elemsize;  // don't expect to change
} arraylist_t;

void al_init(arraylist_t *a, size_t capacity, size_t elemsize);
    // initialize a as an empty list
        // capacity: initial capacity of array
        // elemsize: length of an element
void al_append(arraylist_t *a, void *data);
    // add data to the end of the list

int al_pop(arraylist_t *a, void *dst);
    // remove the last element of a and copy it to *dst, if list is non-empty
    // return 0 on success
    // return 1 on failure

int al_index(arraylist_t *a, void *dst, size_t index);
    // copy data from specified index to dst, if index in range
    // return 0 on success
    // return 1 on failure


Source code posted to Canvas under Files -> Source Code
 
CS 214 / 2022-02-16
===================

In in the Unix model, files are sequences of bytes
-> simplest form of file IO is:
	1. open file
	2. read/write bytes until you reach the end
	3. close file

-> next innovation: use this interface for other things
	-> terminal input/output
	-> network input/output
	-> inter-process communication
	-> hardware device input/output

In C, all I/O is ultimately handled by the operating system

generic to all file-like things
	file descriptors
	read()
	write()
	
specific to files that live on a disk
	open()
	close()
	
file descriptors are just numbers
	each open file is referred to by number
	
	usually:
		0 - standard input
		1 - standard output
		2 - standard error

where do we get file descriptors?
	aside from the standard ones, from functions like open()
	
	int open(char *path, int flags);
	
	int fd = open("my_file.txt", O_RDONLY);
	if (fd < 0) { 
		// could not open the file
	}
	
	char buf[BUFSIZE];
	
	int bytes_read = read(fd, buf, BUFSIZE);
	if (bytes_read < 0)  // error!
	if (bytes_read == 0) // end-of-file (no more input remaining)
	
	close(fd);
	
	
	normally, read advances the "file pointer" or "cursor" that says
		where we are in the file
		-> we don't get the same data twice
		-> we aren't always reading from the beginning of the file
	
	for files on disk/storage, we can use lseek() to move to specific
		points in the file
 
CS 214 / 2022-02-21
===================

C standard vs POSIX standard
----------------------------

C standard library
    stdio.h
    stdlib.h
    many others (most includes!)

    part of the language standard
        present on all conforming C implementations
        
POSIX standard library
    "portable" standard for UNIX-like operating systems
    
    unistd.h
    fcntl.h
    
    not part of the language standard
        POSIX is its own thing
        not all C implementations will have it
        but most will

    tend to be lower-level wrappers around OS calls



opening/creating files
----------------------

two "versions" of open()

    int open(char *filename, int flags);   // when we aren't creating a file
    int open(char *filename, int flags, mode_t mode);  // when we might create a file
    
    if our flags include O_CREAT, we must use the 3-argument form
        the compiler usually won't warn us if we do it wrong!

    filename - a path (relative to the working directory)
    
    flags - bitvector saying how we want to open the file

flags must contain one of these

    O_RDONLY   - open file for reading
    O_WRONLY   - open file for writing
    O_RDWR     - open file for reading and writing

we can use bitwise or to add in additional flags

    O_CREAT   - if the file we want to open does not exist, create it
    O_TRUNC   - if the file we are opening does exist, set its length to 0
    O_EXCL    - fail if the file already exists (used with O_CREAT)


    O_APPEND  - open file in append mode (all writes occur at the end of the file)
    O_NONBLOCK - open file in non-blocking mode


int rd, wr;

rd = open(inputFile, O_RDONLY);   // open a file for reading

wr = open(ouputFile, O_WRONLY);   // open an existing file for writing
    // "overwrites" existing file
    // not typical
    
wr = open(outputFile, O_WRONLY|O_TRUNC);
    // replace contents of existing file

wr = open(outputFile, O_WRONLY|O_APPEND);
    // write onto the end of an existing file
    

wr = open(outputFile, O_WRONLY|O_CREAT|O_TRUNC, permissions);
    // create or replace file (typical scenario)

wr = open(outputFile, O_WRONLY|O_CREAT|O_APPEND, permissions);
    // create or append to file (useful for logging)
    

file modes
----------

In the POSIX model, we have three basic "permissions" on a file
    read
    write
    execute
    
we can assign permissions to three classes of people
    file owner (user)
    file group (excluding owner)
    everyone else (others, excluding owner and group members)
    
    these classes do not overlap!

the read/write/execute flags can be set for each class of people

    chmod  - shell command that sets file permissions
    
    chmod u+x myprogram
        sets the execute bit for user (owner) for myprogram
    
    chmod u-x myprogram
        unsets (removes) the execute bit for the owner


    chmod g+r some_file
        readable by group
    chmod o+r some_file
        readable by others (not owner or in group)
    
    chmod a+r some_file
        readable by everyone

the older way of using chmod is to set the permissions explicitly

    permissions come in groups of three bits - just like octal digits!
    
    three octal digits specify the permissions of a file
        
        600
            110 000 000
            rw- --- ---
            u+r u+w
        
        644 110 100 100
            rw- r-- r--
        
        755 111 101 101
            rwx r-x r-x
            
mode_t is just an int
    
    wr = open("output.txt", O_WRONLY|O_CREAT|O_TRUNC, 0600);
            // in C, a leading zero means octal!

     // open output.txt
     // if it does not exist, create it with permissions u+rw

Posix provides constants for specifying permissions/file mode
    
    S_IRWXUSR   0700 
    S_IRUSR     0600
    
    use bitwise or to combine
    
    S_IRUSR|S_IRGRP|S_IROTH   0666
        read permissions for user, group, and others


error reporting
---------------

we have to expect exceptions
    - files that don't exist
    - might not have permissions
    - file might get deleted while we're using it

C does not have built-in exceptions
    library functions report error conditions in various ways
    there is no standard way to report errors
        various common conventions, but you have to check the manual to know which one

one common strategy
    return value indicates whether there was an error
    global variable errno (error number) is set with the most recent error

for example, open() returns -1 on error and sets errno

    wr = open(fileName, ..., ...);
    if (wr == -1) {
        // report error
        perror(fileName); 
        exit(EXIT_FAILURE);
    }

perror(str)
    prints a string of the form "str: error description"
    
strerror(error_number)
    returns the error description for the error

reading/writing files
---------------------

read() and write() work with byte (char) arrays
    -- not strings!
    
files are not strings
    C strings are terminated by '\0' (therefore cannot contain '\0')
    files do not have terminators
        - all bytes are valid; any byte can occur in a file
        - file length is given in the file's metadata

char buf[] = {'\0', 'a', 'b', '\0', 'd'};
    buf is an array of 5 chars
    but strlen(buf) is 0

write(fd, buf, 5);
 
CS 214 / 2022-02-23
===================

writing test plans
------------------

How will I know that my program is correct?
What does it mean for my program to be correct?

My program should be free of bugs.
    -> true, but vague
    
Think about
    what should my code do?
    what should my code not do?



malloc() should allocate memory
free() should deallocate memory
    -> better, but still too vague


if I allocate N bytes, and get back a pointer, I should be able to write anything
    to those bytes without interfering with (a) malloc's data structures (metadata)
        (b) any other allocated chunks

if I try to allocate more memory than exists, I should get NULL

if I allocate all of memory, I should not be able to allocate more

if I allocate all of memory, then free it, I should be able to allocate more

if I allocate all of memory in multiple chunks,
    and free everything in a different order,
    I should be able to allocate a new, larger chunk

I should detect
    - freeing addresses out of range
    - freeing an address not at the start of a chunk
    - freeing an address at the start of a free chunk


how can you detect metadata corruption?
    - sanity check functions / detect corrupt metadata (where possible)
    - shadow memory for testing
        -> user can't see it, so they can't corrupt it


buffered and non-buffered IO
----------------------------

recall: we have to sets of file IO functions
    open/close/read/write/etc.
    fopen/fclose/fread/fwrite/fscanf/fprintf/etc.

POSIX vs C library
    but also
non-buffered vs buffered

background:
    open (and close, read, write, lseek, etc) are system calls
        -> implementation is part of the operating system kernel
        -> actual implementation details are OS/hardware specific
        -> typically involves a "context switch"
            -> e.g., kernels run the highest permission level
            -> may need to save and restore registers
            -> may need to negotiate time with other processes

    we could request/send data one byte at a time using read/write
        -> but this is inefficient (so many context switches!)

        -> instead of writing bytes one at a time, better to group them up
            write bytes to an array, then send the whole array
        
    we can use a buffer to collect bytes we want to write, and send them all at once
    
read and write are not buffered: we are responsible for buffering

    fread/fwrite/fscanf/fprintf/getc/putc are buffered
        FILE struct includes a byte array
        
    using putc() repeatedly will fill the buffer
        once the buffer is full, it is "flushed" (contents are sent using write())
        (you can force a flush with fflush())


    using getc() will pull bytes from the buffer
        when the buffer is empty, it calls read() to refill the buffer


fdopen()  -> creates a FILE struct for an open file descriptor


blocking vs non-blocking
------------------------

what happens if I request data that is not yet available?
    -> we have to wait for it to become available
    -> we say that file IO "blocks" until data becomes available

what about streams that are not files?
    stdin, network sockets, inter-process communication

we can open files in "non-blocking" mode
    when I request N bytes, I will get up to N bytes
        -> you should never assume that read() gives you as many bytes as you asked for
        
    but what if no data is available?
        read() can't return 0, because 0 means EOF
        
    in blocking mode, read() will block until data becomes available
    in non-blocking mode, read() will return -1 (normally means "error")
        and set errno to EAGAIN or EWOULDBLOCK

we won't use non-blocking IO much in this class
    -> but we should never assume that read() gave us all the bytes we asked for
    -> always check for (1) fewer bytes than requested, (2) 0 (EOF), (3) -1 (error)


directories
-----------

what is a directory?

    every file on disk has a number, called its "inode identifier"
    most files will have a name (path)
    
    /directory/directory/directory/fileordirectory
    
    a directory is a list of files
        links names to file IDs
    
    each file ID refers to a file or another directory (which is also a file)
    
since directories are files, we can open them

opendir()
readdir()
closedir()


    
 
CS 214 / 2022-02-28
===================

readdir(), opendir()
--------------------

recap: a directory is a file that stores names and other information about the files
	in a directory

directories are a list of "directory entries"
	each entry has
		- a file's unique identifier (inode number)
		- the file's name (within the directory)
		- (sometimes) the file's "type"
			DT_REG  - regular files 
			DT_DIR  - directories
			others  - any other kind of file-like object that can live in the file system

examples of non-regular files
	block and characters devices
		see contents of /dev
	
	processes
		see contents of /proc (on linux)
		

useful file: /dev/null
	the "bit bucket"
	contains nothing
	anything written to it is discarded
	-> useful when we want to discard output, or when we need to specify an output file
		but don't want to keep the data


DIR *opendir(const char *name);

	-> open a file as a directory

DIR *opendir(const char *name);
	
	-> close an open directory


struct dirent *readdir(DIR *dirp);

	-> read the next directory entry
	-> each time we call readdir(), we get the next entry
		-> returns NULL after the last entry
		-> we should not assume that the struct is fresh every time
			readdir() may just overwrite the old struct and return the same pointer

DIR *dp;
struct dirent *de;

dp = opendir("my_directory");

de = readdir(dp);
while (de != NULL) {
	puts(de->d_name);
	
	de = readdir(dp);
}

closedir(dp);


stat(), fstat()
---------------

   int stat(const char *pathname, struct stat *statbuf);
   int fstat(int fd, struct stat *statbuf);

standard ways to get (some) information about a file
	e.g., it's size

depending on OS, we may be able to get creation/modification/access times

	see man 2 stat for lots of info about what fields are available (and when)


inodes, path names, links
-------------------------

ever file (and file-like object) has a unique inode number

we also have paths that refer to files, but these are not unique
	there will be at most one file for a path
	but there are infinitely many paths for a given file
	
		/User/Home/Me/my_file
		/User/Home/Me/./my_file
		/User/Home/Me/../Me/me_file

	but there is more to it than this
	
	a directory entry "links" a path to a file (inode number)
		-> but multiple entries can link to the same file (inode number)
			the st_nlink field in the struct stat you get from stat()/fstat() says how
			many links exist for this file

	we can use ln to create new names (links) for an existing file
	
		ln existing_file new_name
		
implications:
	a file's name is not part of the file!
		one file may have many names --- or no name!
		
	the file system tracks how many names are associated with a file
		the OS also tracks how many processes currently have the file open
	
	rm does not actually delete files!
		rm unlinks the file (deletes its directory entry)
		when a file has no links, it is removed
			file system garbage collection

	if your computer shuts down at the wrong moment, the file system can become
		inconsistent
		
		after a crash, Unix will run fsck (file system check) to detect and repair any
		inconsistencies in the file system (where possible)


soft links
----------

"hard links" link a file name to an inode number

a "soft link" (or "symbolic link") refers to another file by name
	a "soft link" has file type LINK and contains a path referring to another file
	
	typically, using the soft link is the same as using the file it refers to,
		but they are actually two different files
		
implications
	a soft link can refer to files that do not exist (or used to exist)
	if we change the name of a file, the soft link breaks
	if we swap the names of two files, the soft link still points to the same name
		-> we can effectively change which file a link refers to without modifying the link
	
	there is no way to learn how many soft links refer to a file

traditional unix does not allow hard links to directories
	but soft links are fine

typical uses
	swap out which program has a particular name
		e.g., we have multiple versions of gcc installed and can swap which one is "the" gcc
	
inodes: what is stored?
-----------------------

problem:
	files are stored in blocks (e.g., 4 KB chunks)
		for efficiency, we don't require these blocks to be contiguous
		-> the data of a file may be stored in multiple places
		-> not a problem, because the inode for a file is in a predictable place

but how can we get access to the contents of our file?
	files can be very small or very large
	inode is a fixed-size record

we could use a linked list, where each block in a file refers to the next block
	-> but this gives us O(n) time to access arbitrary bytes in a file

we could store references to the blocks in the inode
	-> gives us O(1) time to access data in a file
	-> but the inode has to be large enough to store all the references for the largest
		possible file
		-> wastes space, unless most files are very large


instead, inodes (on most unix file systems) use a mixture of direct and indirect references
	-> essentially a lopsided n-ary search tree


example:
	let's say our system has 4096-byte blocks and a block number is 8 bytes
		a data block can contain 4 KB file data or 512 (=4096/8) block references

	the inode contains direct references to a certain number of blocks (e.g., 12)
	the inode contains one indirect reference to a block containing references to
		further blocks (512 blocks)
	the inode contains one double indirect reference: a block containing references
		to blocks that contain references to data blocks (512*512 = 262,144 blocks)
	the inode contains one triple indirect reference (512*512*512 = 134,217,728 blocks)

	so a file would contain between 1 and 134,480,396 blocks (roughly 513 GB)
		but we only have 15 references in the inode itself
	access times slow down as we move further into the file, but we never need more
		than four disk reads to file an particular offset in the file
		
note: these numbers are all made up for the purposes of this example,
 
CS 214 / 2022-03-02
===================

case study: sorting lines in a file

we need to be able to:
	- open a file
	- read the contents of the file and organize it into lines
	- we need a place to store those lines
	- we need to be able to sort the lines

challenges:
	- we don't know how long a line will be
		-> but read() requires us to request a specific number of bytes
		-> we need to be able to deal with a mismatch between buffer length and line length
			-> the buffer may contain multiple lines
			-> lines may be split between consecutive calls to read()
			-> a single line may be split between any number of calls to read()
	- we don't know how many lines there will be


See sortl.c for the code written in class.
	Can you finish it? Can you improve it?

Note the extra target in the Makefile
	sortl  <- production version of code
	dsortl <- same source code, but debug prints enabled
	
My finished version is sortl-2.c
 
CS 214 / 2022-03-07
===================

const
-----

const is a modifier to a variable declaration that makes the variable immutable


const int x = 5;

x = 4;   /* not allowed, because x is declared const */

constant variables must be initialized (because there is no way to modify them later)
    but the initialization can be a non-constant value
    
int foo(int x)
{
    const int a = x;  /* a may be different each time the function is called, but it cannot
                         be modified */

    ... 
}


this gets useful when we combine with functions

int foo(const int *p)    // p points to a read-only int
{
    *p = 0;  // not allowed
}
    // this function cannot modify the data that is passed to it

recall our comparison functions that we use with qsort()

    int compare(const void *a, const void *b);

    this means compare() can read the data that a and b point to, but it cannot write to them
    
the compiler can detect if we call qsort() with a comparison function that does not promise
to only read from the pointers
    - but only if we ask it to, and it still won't actually stop us


const type * var;

    "var points to a read-only type"

const int *p;
    "p points to a read-only int"

contrast with:  
int const *p;

    p is a read-only pointer to an int


    (*p)++
    
const int *p   p points to read-only data, but we can change p
int *const p   p is a read-only pointer, but we can modify *p

const int *const p  p is a read-only pointer that points to a read-only int



struct node {
    int data;
    struct node *next;
};

const struct node head = {0, NULL};




volatile
--------

volatile is a modifier on a variable declaration
    indicates that a variable may change asynchronously
    
    normally, variables only change when you explicitly assign to them
    the compiler can take advantage of this to reduce memory reads
    
    int x = 12;
    while (...) {
        array[i] = x;   // compiler can see that x does not change, so it may avoid re-reading
    }
    
    a volatile variable may change, even if I haven't assigned to it
    
        - could be modified by another thread/process
        - could be a special "memory" location that is not actually memory

const and volatile are sort of opposites, but not actually
    I can declare a const volatile variable!
    
        const volatile int x;
            // this program cannot change x
            // but x may be changed by other programs/hardware/outside forces
        

WARNING: while the above describes the *intention* of volatile, advances in compiler
technology and hardware have made it difficult to describe what guarantees are actually
enforced by volatile. In particular, you should not assume that declaring a global
variable volatile ensures that all threads will see the same value at the same time.
We will discuss effective ways to share mutable data across multiple threads later on.

register
--------

asks the compiler to store a variable in a register

    register int x;
    
    - does not require compiler to store x in a register (might not be enough registers)
    - is not required for the compiler to store a variable in a register
    
    - the only practical difference is that we can't take the variable's address
    
once, this was useful to guide compiler optimization
today compiler optimizers are better than you are at determining which variables to put
    in registers



preview: processes
------------------

the POSIX model

a process is a program that is running
    a course of action that a computer is performing
    
    OS creates processes
        each process has
            - a program that it is executing
            - a memory space
            - list of open files
            - working directory
            - various other configuration details

execl() and execv()
    - change which program a process is executing

fork()
    - duplicates the current process
        the original process is the parent
        the new process is the child
        both processes start with the same contents of memory, open files, etc.

wait()
    - suspends a process until one of its child processes terminates
    
 
CS 214 / 2022-03-09
===================

exec
----

change the program for the current process
	on success, the process will cease executing the current program and begin executing
	the specified program

note that we do not start a new process
	the new program will have the same process ID
	
	other parts of the process control block are preserved, such as the table of open files
		exception: files can be marked "close on exec"
		

two actual functions: execl() and execv()

	need to specify:
		- the program we want to start (path to executable)
		- the arguments (contents of argv)
	
execl() takes a variable number of arguments, terminated by a NULL argument

	execl("program_name", "arg0", "arg1", "arg2", ..., "argN", NULL);
	
	execl("/path/to/program_name", "/path/to/program_name", NULL);
	
	
execv() takes a vector of argument strings, terminated by a NULL pointer

	char *args[] = {"foo", "bar", "baz", NULL};
	execv("foo", args);
	
	
exec does not return, unless it failed


	/* do stuff */
	
	execv(program, pargs);
	
	/* should not get here, except if there was an error */


exec() by itself is not enough to run another program and then get its results


fork
----

duplicates the current process
	the original ("parent") process continues executing
	the new ("child") process also executes, with the same initial state as the parent
		all the files open in the parent are also open in the child
			the OS keeps track of all open files
			a file can be open in multiple processes -- the OS knows how many times a file is open
	
we can think of fork as "returning twice"
	once in the parent, and once in the child


pid_t fork(void);

	in the parent process, fork() returns the PID of the child process
	in the child process, fork() returns 0


typical usage

pid_t child;

child = fork();
if (child == 0) {
	// we are in the child
	...
	exit or exec
}

// we are in the parent
	

wait
----

suspends current process until a child process ends


pid_t wait(int *wstatus);

	wait() returns the PID of the child process that ended
	if wstatus != NULL, it writes the exit status of the child into wstatus
	
	
pid_t child, child2;
int wstatus;

child = fork();
if (child == -1) {
	perror("fork");
	exit(EXIT_FAILURE);
}
if (child == 0) {
	execl(subprogram, subprogram, arg1, NULL);
	
	perror(subprogram);
	exit(EXIT_FAILURE);
}

child2 = wait(&wstatus);

// we would normally expect child == child2 here, since we didn't start any other children

if (wstatus != 0) {
	// something went wrong with our subprogram
}




wait() returns -1 on error
	for example, if there are no child processes


if the parent calls wait() before the child terminates, the parent will wait for the child
to terminate

if the parent calls wait() after the child terminates, we still get the exit status

a "zombie process" is a process that has terminated, but has not yet been wait()ed for
	- the OS keeps track of all running processes, and zombies


an "orphan process" is a process whose parent has terminated

	if an orphan process terminates, it becomes a "zombie orphan"
	
to avoid clogging up the process table with zombie orphans, the OS will have one or more
processes that "adopt" orphans
	e.g., init (the first process) will adopt an orphan and wait for it, to clean out
		the process table


communication between parent and child is limited



pipe
----


pipe() creates a pair of linked files
	anything written to the second one can be read from the other one
	
	
int pipe(int fd[2]);
	// returns 0 on success
	// returns -1 on failure and sets errno


int p[2];

pipe(p);

p[0] is the read end
p[1] is the write end

if we create a pipe before we fork, then both parent and child will have access to the pipe

int p[2];
pipe(p); // FIXME: check for errors

if (fork() == 0) {
	close(p[0]);
	write(p[1], "hello", 5);
	exit(EXIT_SUCCESS);
}
close(p[1]);  // make sure to close our copy of the read end, so that we can detect when
// the child finishes writing to p[1]

while ((bytes_read = read(p[0], buffer, buflength)) > 0) {
	... do stuff ...
}



dup() and dup2()
----------------

these duplicate an open file (create a new file descriptor that refers to the same open file)

dup() will create a new file descriptor for an existing file, using an available number
dup2() creates a new file descriptor with the requested number

dup2(some_file, 0);


----
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define SUBPROG "/usr/bin/wc"
		// feel free to try this with other programs
#define BUFSIZE 32

int main(int argc, char **argv)
{
    // create pipes for the subprocess's stdin and stdout
    int subin[2], subout[2];
    pipe(subin);
    pipe(subout);
    // FIXME: check for errors

    pid_t child = fork();
    if (child == 0) {
        // child process
        // close write end of subin and read end of subout
        close(subin[1]);
        close(subout[0]);

        // close stdin and stdout
        close(0);
        close(1);

        // set stdin and stdout
        dup2(subin[0], 0);
        dup2(subout[1], 1);

        execl(SUBPROG, SUBPROG, NULL);

        perror(SUBPROG);
        exit(EXIT_FAILURE);
    }

    // parent process
    // close read end of subin and write end of subout
    close(subin[0]);
    close(subout[1]);

    // anything we write to subin[1] will go to the child
    // anything the child writes to stdout, we can read from subout[0]


	// super-simple example; try something more interesting!
    write(subin[1], "hello ", 6);
    write(subin[1], "world\n", 6);
    close(subin[1]);

    int bytes;
    char buf[BUFSIZE];

    while ((bytes = read(subout[0], buf, BUFSIZE)) > 0) {
        write(1, "Got: |", 6);
        write(1, buf, bytes);
        write(1, "|\n", 2);
    }

    wait(NULL);

    return EXIT_SUCCESS;
}
----
	



CS 214 / 2022-03-21
===================

Midterm exam 3/23
-----------------

we're going to do on-line for this one
    - don't come to lecture; do go to recitation

exam will be given through Canvas

    - become available at 2:00 PM on Wednesday
    - will be available until 2:00 PM on Thursday

I will trust you not to look up answers on-line
- otherwise, open book and open notes

I will aim for 30-40 minutes

od
--

od - octal dump
    print the contents of a file with minimal interpretation
    useful to see "invisible" characters in text files 
        (non-printing control characters)
    (possibly) useful to look at the contents of non-text files

man 3 od

od -c <file>

    prints each byte as a character, but uses \ escapes for special characters
    
od -t x1 <file>
    
    prints each byte in hexadecimal
        x for heXadecimal
        1 for 1-byte chunks


./ww testfile | od -c

    one way to check the output of ww "by eye"




recap: exec and fork
--------------------

execl() and execv()
    change the program that the current process is executing

    execl gives arguments in its argument list
            
        execl("/path/to/program", arg0, arg1, arg2, arg3, ..., NULL);
        
            typically, arg0 is the same as the path to the program
        
    
    execv gives arguments in an array of string (pointer)s
        
        char *args[] = { path, "arg1", "arg2", NULL };
        execv(path, args);

    exec DOES NOT RETURN (unless something went wrong)
        
        
fork()
    duplicates the current process
        original process is the parent
        new process is the child
    
    initially, both processes will be (nearly) identical
        same contents of memory
        same open files (and other OS info)
        same place in program (in a sense, fork "returns twice")
    
    differences:    
        child process will have a new PID
        fork() will return different values
            in the child, fork() returns 0
            in the parent, fork() returns the PID of the child

wait()
    suspends a process until a child terminates
        

what happens if I call fork twice?
    fork();
    fork();

the "fork bomb" is a process that repeatedly forks

    while (1) fork();
    
    - this creates exponentially many processes
        - overwhelming the active process table and using all the resources of
            the computer
    - most well-administered computers will detect this and try to counter
    - don't do this on the iLab - LCSR will know who did it


signals
-------

another way to communicate with a running process
    typically send by the OS to indicate that something has happened

signals are asynchronous: they can arrive at any time

when a signal is sent to a process, it first becomes "pending"
    after a brief period, it is "delivered"
    what happens in delivery depends on the process's "disposition"
    
dispositions that a process can have
    - block the signal (signal remains pending until process stops or signal is
        unblocked)
    - ignore the signal
    - terminate
    - call a signal handler

a signal handler is a function that will be called when its signal is delivered
    when the signal is delivered, the current code is interrupted and the
    signal handler is pushed onto the stack
        when the handler returns, the process will resume doing whatever it
        was doing before the signal

each signal is identified by a numeric code
the codes are different

    SIGHUP  - user has logged out (usually terminates process)
    SIGINT  - interrupt the current process (and usually terminate)
        happens when the user types control-C
    SIGTERM - terminate the current process
        default signal for "kill" program
    SIGQUIT - terminate and dump core (used for debugging)
    SIGABRT - sent by abort()
    SIGKILL - stop the process immediately (cannot be blocked or handled)
        does no cleanup


    SIGSTOP - suspend the current process
    SIGTSTP - user typed control-Z (can be handled or ignored)
    SIGCONT - process is resuming from suspension


    SIGCHLD - child process has terminated or stopped


man 7 signal
    - lists common signals and their default dispositions
    
man 2 signal
    - describes signal(), the traditional way to change disposition for a signal
    

    signal(SIGINT, SIG_IGN);
        // change disposition for SIGINT to ignore
        // this will prevent control-C from terminating your program
        // not usually a good thing to do

examples of using the program below:

$ ./sig &
[1] 995850
$ kill 995850
$ caught signal: Terminated
We are in the exit handler

[1]+  Done                    ./sig
$ ./sig &
[1] 995885
$ kill -KILL 995885
$ 
[1]+  Killed                  ./sig
$ ./sig &
[1] 995947
$ kill -INT 995947
$ caught signal: Interrupt
We are in the exit handler

[1]+  Done                    ./sig
    

Note: putting & at the end of a command tells the shell
to start the process "in the background"
    the shell tells us the PID of the process

kill <PID>
    - sends SIGTERM to the specified process

kill -KILL <PID>
    - sends SIGKILL to the specified process

kill -INT <PID>
    - sends SIGINT to the specified process

Note that sig halts immediately when it receives SIGKILL,
instead of printing a message.

----
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <signal.h>

volatile int signo = 0;
    // marked volatile because it may change asynchronously
    // that is, signals may be received at any time


// very simple signal handler
// note that it returns normally, so we can only use it with non-error signals
void handler(int signum)
{
    signo = signum;
}

// a very simple exit handler
void make_a_note(void)
{
    puts("We are in the exit handler");
}

int main(int argc, char **argv)
{
    // register an exit handler: make_a_note will be called after main returns
    atexit(make_a_note);
    
    // register some signal handlers
    // we can reuse handler because it will receive the signal
    signal(SIGHUP, handler);
    signal(SIGINT, handler);
    signal(SIGTERM, handler);
    signal(SIGCONT, handler);

    pause();  // stops the process until a signal is received
    // alternative:
    // while (signo == 0) { puts("Waiting"); sleep(1); }

    if (signo > 0) psignal(signo, "caught signal");
    
    return EXIT_SUCCESS;
}




CS 214 / 2022-03-28
===================

midterm
-------

Average score was 67%

If you need to take a makeup exam (for medical or other emergency reasons)
    please e-mail me TODAY
    use the subject line "[CS214] Midterm Makeup"

I would like to be able to discuss the exam and correct answers on Wednesday


Projects II and III
-------------------

Project II will be extended to Friday night (April 1) (not a joke)

Project III will be rewriting Project II to be multithreaded
 - you may re-use your code from project II
 - if you are working with someone else, you may use either partner's code 
   or take elements from both

There will be some chances for extra credit, but they will be a further jump
in complexity

Reminder: you must use open(), read(), write(), and close()
    you must not use fopen(), fscanf(), fgets(), fclose()
        printf()/fprintf() are okay for error messages

note on sprintf(): be careful with the buffer length!
    sprintf() does not know how many bytes it has to work with, so it assumes
        the buffer you give it is big enough
    snprintf() is the safer version

standard input and standard output
    standard input is file descriptor 0
    standard output is file descriptor 1
    standard error is file descriptor 2
    
        read(0, buf, length);
        
your program will do one of:
    read from 0, write to 1
    read from some file, write to 1
    read from some file, write to another file
    
    the first two are just special cases of the third scenario!
    
how do you open a file in a different directory?
    one possibility: append file name to directory name, with / separator
        directory_name/file_name
        (note: don't add a second slash if the directory name was given with a slash)

    use chdir() to change the working directory
        -> recall that open() is given a path relative to the working directory


how do we test reading from stdin?
    you can just start your program and type Control-D at the start of a line
    
    alternately, use shell redirection
    
        ./ww 80 < input_file
        cat input_file | ./ww 80


signals
-------

a form of asynchronous communication with a process
    -> at any time, your process may receive a signal
    
signals are a form of interrupt
    -> receiving a signal interrupts the normal flow of your process
    -> sometimes, it is possible to resume the process where it left off once
        the signal is handled

there are two important kinds of signals
    some signals indicate errors/exceptional conditions
        SIGFPE (floating-point exception)
        SIGSEGV (invalid memory access/segmentation violation)
        others
        
        -> it is not generally safe to resume from an error signal
            if you got one of these errors, an unknown part of your program's
            state has been corrupted

    other signals are more like messages or requests
        SIGINT, SIGKILL, SIGABRT, SIGQUIT, SIGHUP
            ask the process to terminate, with varying degrees of force
        
        SIGSTOP, SIGTSTP - used to pause a process
        SIGCONT - sent when a paused process resumes


        SIGCHLD - sent when a child process terminates
    
        several others
        
some signal-related functions
    int pause(void);   // suspend process until any signal is received
    int kill(pid_t pid, int sig);   // sends signal to specified process
    int raise(int sig);   // sends signal to same process

    typedef void (*sighandler_t)(int);
    
    sighandler_t signal(int sig, sighandler_t handler);
    
        installs or removes a handler function for a particular signal type
    
    some constants:
        SIG_ERR - returned by signal() if there was a problem
        SIG_IGN - handler that ignores a signal()
        SIG_DFL - handler that does the default action for the signal

    dispositions: what to do when a signal arrives
        ignore
        terminate
        terminate and "dump core" (potentially useful for debugging)
        stop
        continue
        ... or a custom handler function
    
    a signal handler is a function that takes a signal number and returns nothing
        void handler(int signal_number);

        a signal handler that exits normally will allow the program to resume
            -> not safe to do for error signals, because the error will just
                reoccur
        
        signals may also call exit() or exit_() to terminate the process
        you can sometimes use longjmp() to resume your process somewhere else
            -> this is more advanced than we want to get into


signals can also be blocked
    normally when we send a signal, it starts as pending and then is delivered
    if the signal is blocked, it stays pending until
        - the signal is unblocked
        - the process terminates

    can be useful to temporarily delay receipt of certain signals


multitasking
------------

we have already seen fork()
    - a process can create multiple child processes
    - we can use the initial state of memory to tell each child what to do
    - we can communicate using
        pipes
        signals
        shared memory regions (out of scope for this class)
        the file system
        
but we can have concurrent processes that are even more closely connected:
    threads

-> we will discuss the POSIX Threading library (pthreads)




CS 214 / 2022-03-30
===================
note: signal safety
-------------------
man 7 signal
man 7 signal-safety
What is it safe to do in a signal handler?
- not all functions are safe to call from a signal handler
-> many library functions cannot be called from a signal handler 
safely
many library functions are not "re-entrant"
it is not safe to call the function while the function is already 
active
-> normally not a problem
generally, it is okay to do simple "atomic" actions in a signal handler
e.g., assigning to a global variable
give this a try! use signal() to intercept SIGINT or SIGHUP
multitasking, multiprocessing, multithreading
---------------------------------------------
even on a single CPU, it is possible to run multiple processes at once
multitasking
there are two main strategies for writing a multitasking system
cooperative multitasking
processes use a special system call ("yield") to give up control
and allow other processes to run
problem: vulnerable to buggy/malicious code
advantage: simpler to design, requires less hardware support
can guarantee you won't get interrupted at an important moment
preemptive multitasking
OS divides time into "slices"
each process gets one slice
OS uses hardware interrupts to seize control when the time slice 
ends
this requires additional hardware support
have to be able to suspend an active process at any point
and resume it later
-> need to save contents of registers, instruction pointer, 
etc.
advantage:
client programs don't need to do anything
badly written/malicious clients can't cause problems
interrupts
-> this is a hardware concept
the CPU interrupts its normal control flow to do something else,
and usually resumes what it was doing later
interrupts are happening all the time
input devices (keyboard, mouse)
network devices
timers
we don't normally see this as application programmers because the OS
handles them
-> one kind that we do see are signals
even under preemptive multitasking, we are not guaranteed to get our whole 
slice
e.g., calling sleep() or pause() will immediately suspend our process
functions that block (e.g., read()) will also end your time slice
scheduling
OS will have a system for deciding which process to run next
and for determining how much time to give to each process
"round robin" : run processes one after another, when every process 
has
had a turn, go back to the start of the list
a typical addition to this is priority
some processes might get bigger time slices
some low-priority processes might not get to run until higher-
priority
processes are finished/blocked
we can affect the priority of a process using commands such as "nice"
we have seen how to take advantage of multitasking to perform multiple 
operations
concurrently: using fork()
on systems with multiple CPUs, the OS can schedule tasks on different CPUs
multiprocessing means having multiple processors: being able to do two or
more things simultaneously
MIMD (multiple instruction, multiple data)
SIMD (single instruction, multiple data)
same operation is performed multiple times simultaneously on 
different
data
called "vector processing"
what a GPU does
SIMD is easier to make hardware for
MIMD is easier to program for






CS 214 / 2022-04-04
===================
We have talked about
- multiprocessing
having multiple CPUs
being able to execute multiple instructions simultaneously
SIMD vs MIMD
- multitasking
dividing the time of a CPU among multiple tasks/processes
cooperative vs preemptive
multithreading
multitasking within a single process
each thread is effectively a process
- instruction pointer
- stack
- register context
unlike multiprocessing, threads all share a memory space
shared memory gives us much faster communication between threads
and easier coordination
but it makes it much easier for threads to interfere with each
other
-> more effort is required to respect invariants
even simple tasks like incrementing an integer variable can consist
of multiple steps
-> problems can arise if multiple threads perform these steps
concurrently
imagine a global integer variable X
thread A    thread B
read X
read X
compute X+1
compute X+1
write X+1
write X+1
even though both threads incremented X, we only got the effect of
a single increment
we can talk about two forms of multithreading
OS threads / kernel threads / heavy threads
these are essentially separate processes that share memory space
scheduled by the OS
may be executed on separate processors
library threads / language threads / "green" threads
typically lightweight, compared to OS threads
may use cooperative or preemptive scheduling
appear as a single thread to the OS (can only use one CPU)
In C, we will use "POSIX Threads" aka "pthread"
man 7 pthread
Use -pthread when compiling
#include <pthread.h>
int   // 0 on success, error number on failure
pthread_create(
pthread_t *thread,   // where to write the ID of the created thread
const pthread_attr_t *attr,  // configuration data
void *(*start_routine) (void *),   // function to execute in the 
thread
void *arg  // argument to pass to the thread
);
start_routine is sometimes called a void*/void* function
because it takes a void * argument and returns a void *
this is a lot like a function call, except:
the function will execute concurrently
the function's return value is obtained asynchronously
void *do_something(void *arg)
{
puts("This is happening in the background!");
}
...
pthread_t tid;
pthread_create(&tid, NULL, do_something, NULL);
puts("This is happening in the foreground!");
pthread_join(tid, NULL);  // wait for thread to finish, obtain return 
value
int  // returns 0 for success, error number on failure
pthread_join(
pthread_t thread, // ID of thread we want to wait for
void **retval     // where to write the void * that the thread returns
);
we can make an analogy with fork/wait
every thread that is created must be joined
-> difference: subprocesses have a parent/child relationship
only a process's parent can wait for it
-> threads are peers
any thread can join any other thread
in particular, we can write code where thread A starts thread B,
and then thread B joins (waits for) thread A
-> typically, we just have the main thread start one or more worker 
threads
and then wait for them to finish
simple example
adding the elements of an array using "divide and conquer"
int global_array[SIZE];
struct worker_data {
int start;
int stop;
int dest;
};
void *worker(void *arg)
{
struct worker_data *A = arg;
int i, total = 0;
for (i = A->start; i < A->stop; i++) {
total += global_array[i];
}
A->dest = total;
return NULL;
}
...
// create N threads to add up portions of global array
// what information would our worker functions need?
// - range of elements in array to add up
// - where to write the answer
pthread_t tids[N];
struct worker_data args[N];
int chunk = SIZE / N;
for (i = 0; i < N; i++) {
args[i].start = chunk * i;
args[i].stop  = chunk * (i + 1);
// FIXME: handle case where SIZE is not a multiple of N
pthread_create(&tids[i], NULL, worker, &args[i]);
}
// wait for all threads to finish
int total = 0;
for (i = 0; i < N; i++) {
pthread_join(tids[i], NULL);
total += args[i].dest;
}
The point of threading is to take advantage of shared memory
-> but shared memory is inherently unsafe
-> how can we mitigate this unsafety?
we need hardware support for "atomic" instructions
"atomic" here means "indivisible"
test-and-set
consider something like incrementing a value in memory
three steps:
read from memory
do math
write to memory
test-and-set
reads from a memory location and writes to it in a single step
we state (1) what to write to the memory location and (2) what we
expect to see there
if the value present matches, we do the update and succeed,
otherwise, we fail
we can use this to set a "lock" on a data structure
only one thread has access at a time
if one thread gets access, no other thread can get access until the 
first
thread has finished
-> mutual exclusion
a resource that can be used by at most one thread at a time
pthread_mutex_t
int
pthread_mutex_init(
pthread_mutex_t *mutex,     // location of mutex to initialize
pthread_mutex_attr_t *attr  // optional configuration, or NULL for 
defaults
);
int
pthread_mutex_destroy(
pthread_mutex_t *mutex   // location of mutex to destroy
);
int pthread_mutex_lock(pthread_mutex_t *mutex);
// request exclusive access
int pthread_mutex_unlock(pthread_mutex_t *mutex);
// finished with exclusive access
You can have as many mutex variables as you want
They are not themselves associated with data
-> the lock by itself doesn't protect anything

struct linked_list {
     struct node *head;
     pthread_mutex_t lock;
};

struct node {
...
};

struct linked_list *create_list(void)
{
     struct linked_list *L = malloc(sizeof(struct linked_list));
     L->head = NULL;
     pthread_mutex_init(&L->lock, NULL);
     return L;
}

void insert(data_t data, struct linked_list *L)
{
     pthread_mutex_lock(&L->lock);
     // actual code to insert into the list
     // code between the lock and unlock will be run by one thread at a time
     pthread_mutex_unlock(&L->lock);
}

Note: nothing stops me (or someone else) from writing code that
modifies the linked list without getting the lock first. Pthread
mutexes work on the "honor system".
having mutexes allows us to avoid the problems of shared memory
-> whenever we have a resource that is being used by multiple threads,
we can use a mutex to avoid threads making changes concurrently
-> sophisticated use of mutexes can be pretty complicated
-> determining where to use a mutex, and at what granularity can be tricky
-> balance of complexity and flexibility
-> more complex schemes are vulnerable to bugs/bad design
But mutexes are not sufficient for all use cases
Producer/consumer problem
one or more threads creating data (inserting into a queue, for 
example)
one or more threads reading data (dequeueing from the queue)
what happens if the consumers are faster than the producers?
- we need to wait until more data becomes available
- we could sleep for a short period and hope more data arrives
- we could just loop and repeatedly check
-> the solution here is condition variables
a condition variable is essentially a Boolean value
threads can sleep until the condition becomes true






CS 214 / 2022-04-06
===================
Final Exam:
May 10, 12:00 PM - 3:00 PM, in our classroom
(unless we have to switch to on-line via Canvas for safety reasons)
If you have a conflict with that time, please e-mail me as soon as you can
subject line: [CS214] Exam conflict
include your full exam schedule, so I can schedule a makeup

recap
-----
int
pthread_create(
pthread_t *tid,
pthread_attr_t *attr,
void *(*start_function)(void *),
void *arg);
-> system call used to create a thread
-> we provide a function that the thread will execute,
also an argument to provide to the function
void
pthread_exit(void *retval);
-> terminates the current thread, sets retval as the return value
-> equivalent to returning from start_function
int
pthread_join(
pthread_t tid,
void **retvaldest);
-> waits for the specified thread to end
-> if retvaldest != NULL, the return value will be written there
pthread_t tid;
err = pthread_create(&tid, NULL, worker_fun, NULL);
// do other stuff
void *ret;
err = pthread_join(tid, &ret);
// now ret will be the pointer returned from the thread
int pthread_detach(pthread_t tid);
-> tell the thread to clean up after itself
-> useful in certain designs, but not usually the best choice
-> note that all threads end when the process ends
note:
the process always ends when
(a) main() returns
(b) any thread calls exit()
(c) any thread calls exit_()
recall:
a process is a collection of one or more threads that share a memory
space & various OS resources and configuration details
a thread is an execution context
program counter/instruction pointer
register context
stack


mutual exclusion
----------------
idea: control access to a shared resource to avoid interference from
concurrent thread access
-> "synchronized" access
pthread provides a primitive mutex "lock"
idea: before accessing a shared resource, acquire the lock
when finished, release the lock
pthread_mutex_t  <- abstract type; maybe a struct?
pthread_mutex_init     - sets up fields, maybe allocates things?
pthread_mutex_destroy  - maybe deallocates things?
pthread_mutex_lock   - obtains exclusive access, or blocks until it can
// code between lock and unlock is synchronized
pthread_mutex_unlock - release exclusive access


producer/consumer problem
-------------------------
one or more threads adding data to a queue (or stack or whatever)
one or more threads obtaining data from the queue
-> what happens if the queue is full?
-> what happens if the queue is empty?

struct queue {
     int data[QUEUESIZE];
     int start, stop;
     int full;
     pthread_mutex_t lock;
     pthread_cond_t enqueue_ready, dequeue_ready;
};

int queue_init(struct queue *q)
{
     q->start = 0;
     q->stop = 0;
     q->full = 0;
     pthread_mutex_init(&q->lock, NULL);
     pthread_cond_init(&q->enqueue_ready, NULL);
     pthread_cond_init(&q->dequeue_ready, NULL);
     return 0;
}

int enqueue(int n, struct queue *q)
{
     pthread_mutex_lock(&q->lock);
     while (q->full) {
          pthread_cond_wait(&q->enqueue_ready, &q->lock);
     }

     q->data[q->stop] = n;
     q->stop++;
     if (q->stop == QUEUESIZE) q->stop = 0;
     if (q->start == q->stop) q->full = 1;
     pthread_cond_signal(&q->dequeue_ready);
     pthread_mutex_unlock(&q->lock);
     return 0;
}

int dequeue(int *n, struct queue *q)
{
     pthread_mutex_lock(&q->lock);
     while (!q->full && q->start == q->stop) {
          pthread_cond_wait(&q->dequeue_ready, &q->lock);
     }
     * n = q->data[q->start];
     q->start++;
     if (q->start == QUEUESIZE) q->start == 0;
     q->full = 0;
     pthread_signal(&q->enqueue_ready);
     pthread_mutex_unlock(&q->lock);
     return 0;
}









CS 214 / 2022-04-11
===================

Project III notes
-----------------

Parts I and II are subsets of part III. You don't need a special
case to handle -r: you MAY treat it the same as -r1,1

Your main thread MAY participate as a worker thread, or simply
wait for all worker threads to terminate and then terminate the
process.

I recommend against detach. Use join instead
-> ensure all worker threads are finished before process termination
-> you need to be able to set the exit status
    (any thread can call exit() to terminate process with exit status,
     but it is simpler to centralize this)
    

strcat()
    
    strcat(dest, src)
        copies src to the end of dest
        (requires dest to be in a large enough buffer)
        
            strcat(path, directory_name);
            strcat(path, "/");
            strcat(path, file_name);

        for (i = 0; i < strlen(string); i++) { }  // no!
        
        int len = strlen(string);
        for (i = 0; i < len; i++) { } // better!


    conceptually:
        file threads get (paths to) files from the queue
        
        "foo/bar/baz/quux.txt"
        ->
        "foo/bar/baz/wrap.quux.txt"

    better:
        ("foo/bar/baz", "quux.txt")

conundrum: when is it safe to free path strings?


recap
-----

pthread_create
    -> creates a new thread
    -> new thread will start "soon"
    -> no guarantees that threads will start in the order they were
       created
       

danger of re-using thread arguments

    main
    ----
    
    set struct to A
    start thread 1
    set struct to B
    start thread 2
    
    no guarantee that thread 1 sees A! both threads may see B!
    
problem: unsynchronized use of shared memory
solutions
    - add synchronization (but what?)
    - don't share

note: a mutex MUST only be unlocked by the same thread that locked
    "checked" mutexes will confirm that the correct thread does the unlock
    but if your code is written correctly, the check will never fail



condition variables: signal vs broadcast
----------------------------------------

pthread_condition_wait
    -> suspends thread until a signal is sent to the condition

pthread_condition_signal
    -> wakes up 1 thread waiting for the condition
    -> nothing happens if no threads are waiting

pthread_condition_broadcast
    -> wakes up all threads waiting for the condition


barriers
--------

iLab does not have man pages for these. see:
    https://man7.org/linux/man-pages/man3/pthread_barrier_init.3p.html
    https://man7.org/linux/man-pages/man3/pthread_barrier_wait.3p.html


a barrier stops threads until a certain number of threads are waiting

    pthread_barrier_t

a barrier is created with a certain number
    
    int pthread_barrier_init(
        pthread_barrier_t *barrier,
        pthread_barrierattr_t *attr,
        unsigned count);

    int pthread_barrier_destroy(pthread_barrier_t *barrier);


the wait operation blocks a thread until the correct number of threads
    are waiting

    int pthread_barrier_wait(pthread_barrier_t *barrier);
    
    
e.g., create a barrier for two threads

    thread A    thread B
    --------    --------
    do stuff    do stuff
    do stuff    do stuff
    do stuff    wait
    wait
    do stuff    do stuff
    wait        do stuff
                do stuff
                wait
    do stuff    do stuff

barriers are reusable


application: sharing thread argument structs
(not necessarily recommended, but it will work)

pthread_barrier_t B;

{
    ...
    pthread_barrier_init(&B, NULL, 2);

    for (...) {
        struct thread_arg arg = ...;
        
        pthread_create(..., ..., worker, &arg);
        
        pthread_barrier_wait(&B); 
            // pause main thread until worker has finished
            // reading arg
    }
    ...
}

void *worker(void *arg)
{
    ...
    // read arg
    ...
    pthread_barrier_wait(&B);
        // wake up main thread
        // we cannot safely refer to arg after this
    
}


semaphores
----------

the original tool for synchronization

we can think of a semaphore as an integer with two operations

    V / post / increase / sem_post
        - increases the integer by 1
        - if any threads are waiting, wakes one up

    P / wait / decrease / sem_wait
        - if integer is 0, blocks
        - decreases the integer by 1


	the initial value of the integer is set by create / sem_init

we can draw an analogy to mutex
	initial value is 1
    wait is like lock
    post is like unlock

we can draw an analogy to condition variables
	initial value is 0
    wait is like cond_wait
    post is like cond_signal


more on this on Wednesday

example: bounded queue using three semaphores


#include <semaphore.h>

typedef struct {
    data_t data[QUEUESIZE];
    int start, stop;
    sem_t spots_open;
    sem_t spots_filled;
    sem_t lock;
} queue_t;

void queue_init(queue_t *Q)
{
    start = 0;
    stop = 0;
    sem_init(&Q->lock, 0, 1);
    sem_init(&Q->spots_open, 0, QUEUESIZE);
    sem_init(&Q->spots_filled, 0, 0);
}

void enqueue(queue_t *Q, data_t d)
{
    sem_wait(&Q->spots_open);
    
    sem_wait(&Q->lock);
        Q->data[Q->stop] = d;
        Q->stop++;
        if (Q->stop == QUEUESIZE) Q->stop = 0;
    sem_post(&Q->lock);

    sem_post(&Q->spots_filled);
}

void dequeue(queue_t *Q, data_t *p)
{
    sem_wait(&Q->spots_filled);

    sem_wait(&Q->lock);
        *p = Q->data[Q->start];
        Q->start++;
        if (Q->start == QUEUESIZE) Q->start = 0;
    sem_post(&Q->lock);
    
    sem_post(&Q->spots_open);
}









CS 214 / 2022-04-13
===================

Project III clarification
-------------------------

In the writeup, I refer to a directory name queue and file name
queue.
-> note: these do not need to be FIFO queues
-> the actual requirement is that everything added to the queue
    gets removed exactly once

Be careful when sharing heap objects among multiple threads
-> need some way to decide which thread will free the object

three approaches work well in C
- reference counting (requires synchronization)
- one thread uses malloc(), hands off to another thread,
    recipient uses free()
    - once the creator hands off the object, it must not refer
      to it again
- one thread creates object and "loans" it to one or more other
    threads
    - once the recipients are finished, the creator can free the
      object


Deadlock
--------

Be careful when you use more than one mutex

Consider: two threads (A, B) and two mutexes (X, Y)

    thread A     thread B
    --------
    locks X
    locks Y
    unlocks Y
                locks Y
    unlocks X
                locks X
                unlocks X
                unlocks Y

this is fine, but...

    thread A     thread B
    --------
    locks X
                locks Y
    locks Y
                locks X
    unlocks Y
    unlocks X
                unlocks X
                unlocks Y

deadlock!
    each thread is waiting for the other thread to release
        a resource, but neither thread can release the resource
        because it is waiting
        
deadlock is not generally resolvable at run-time
deadlock is not generally detectable at run-time


the only way to resolve deadlock is to never get deadlocked

for deadlock to be possible, 4 conditions must be true

1. mutual exclusion 
    it must be possible to have exclusive access to some resource
2. hold and wait
    it must be possible to block while holding exclusive access
    e.g., blocking while trying to lock Y does not release lock
        on X
3. no pre-emption
    only the thread holding a lock can release it
    e.g., no other thread can unlock a lock
4. circular wait
    e.g., X waits for Y while Y waits for X
    e.g., X waits for Y, Y waits for Z, Z waits for X


How can we avoid deadlock?
- be careful
- strategy: always acquire multiple resources in the same order
- don't use mutex
    - there are a few alternatives to mutual exclusion/locks
      for synchronization (e.g., transactional memory)
- prove that deadlock cannot occur
    - unfortunately, most languages are hard to analyze formally
- detect deadlock at run-time
    -> hard to correct deadlock, but detecting can improve our code
- be careful
    - design your systems and APIs to make deadlock impossible or
        unlikely

Monitors
--------

a higher-level synchronization structure

e.g., a data structure that handles its own synchronization needs

    our synchronized queues can be considered monitors, assuming
        enqueue() and dequeue() are separate functions

monitors can be much more complicated
e.g., we could allow multiple concurrent read accesses or one
    write access at a time
    
- monitors managing multiple mutexes can potentially detect/resolve
    deadlock


Semaphores
----------

the original synchronization primitive

broadly speaking: two kinds of semaphores
    binary semaphore
    counting semaphore

both are a synchronized integer 
    counting semaphore is always non-negative
    binary semaphore is always 0 or 1

create / init
    sets the initial number for the semaphore

V / post / increase / signal / sem_post
    increases the number of the semaphore
P / wait / decrease / sem_wait
    if semaphore is zero, waits until another thread posts
    decreases the number



mutexes are restricted semaphores
    initial number is 1
    mutex_lock is sem_wait
    mutex_unlock is sem_post
    
    
condition variables are restricted semaphores
    initial number is 0
    cond_wait is like sem_wait
    cond_signal is like sem_post


we can think of a counting semaphore as giving availability of resources

e.g., in a synchronized queue we can have
    1 semaphore acting as a lock
    1 semaphore counting open space in the queue
    1 semaphore counting available data in the queue
    

init (size n):
    lock.init(1)
    data.init(0)
    free.init(n)

dequeue:
    data.wait()
    
    lock.wait()
        remove the data from the queue
    lock.post()
    
    free.post()

enqueue:
    free.wait()
    
    lock.wait()
        add data to the queue
    lock.post()
    
    data.post()
    

one last point about (POSIX) semaphores:
on posix, we have "memory" semaphores (usable by one process)
    and "named" semaphores (usable by multiple processes)











CS 214 / 2022-04-18
===================

Project III will be extended until Monday, April 25
- Additional Part IV for extra credit will be posted soon

Project IV is cancelled
- I hope to post a non-graded exercise for writing network code


read/write lock
---------------

we have a shared, synchronized data structure
- most accesses are read-only
    -> we can allow simultaneous read access without worrying about synchronization
- we do have some write accesses
    -> changes must be made with exclusive access
    -> two simultaneous changes can interfere
    -> one thread changing while another reads can interfere

the model is:
    1 write thread at a time
    1 or more read threads at a time
    no reads and writes at the same time

mutexes give exclusive access
    not enough to allow non-exclusive read access


See code posted to Canvas for the example.

Exercise: can you arrange the access pattern to demonstrate write requests starving read
requests?


starvation
----------

shared resource that multiple threads want access to, but
some threads are never able to get access

starvation is similar to deadlock, in that it is dynamic
-> starvation can be more subtle to detect


may occur whenever access to a shared resource does not have some fairness mechanism
built-in (e.g., a queue to ensure the longest-waiting thread gets access first)










CS 214 / 2022-04-20
===================

Project notes
-------------

If you worked with someone, you should be in the same group

Please mention both partner's names & net IDs in the README


Multithreading
--------------

Synchronization is necessary when we have:
    - data shared across multiple threads
    - shared data can change over time


do we need to synchronize read access to a single integer?
    seemingly, if one thread reads and another writes,
        the reading thread will either get the old value or
        the new one
    -> unless we know the hardware guarantees this, we cannot
        assume it



is_empty()
dequeue()
dir_threads_working()

while (!is_empty() || dir_threads_working()) {
    dequeue()
    do stuff
}


A                   B
is_empty()
    => true
                    enqueue()
                    terminates
dir_threads_working()
    => false
terminates

---

we can rearrange the test to take advantage of the fact
that dir_threads_working() transitions from true to false, but
not back

while (dir_threads_working() || !is_empty()) {
    dequeue()
    do stuff
}

A                           B
dir_threads_working()
    => false
!is_empty()
    => true
                            dequeue()
                                => queue now empty
dequeue()
    => blocks forever?

---
a solution:

add a close() operation to the pool
    -> close indicates that no more will be added to the pool
    -> any threads waiting to dequeue are awakened and fail dequeue

allow dequeue() to fail if the pool is empty and closed
    -> dequeue blocks until 
        (1) pool is non-empty, or
        (2) pool closes

having one atomic dequeue solves all the problems above

while (dequeue() suceeds):
    do stuff


Network communication
---------------------

network communication is about sending messages from one process to another
-> where the processes may be on different machines
-> where the machines may not be directly connected

what do these messages look like?
how do I indicate where the messages are going?
what happens if messages get lost? or come out of order?
what if multiple processes are trying to send messages at once?


Physical and Link layers
    one machine communicates directly with another
        (technically each network card would be considered separately)
    similar to talking in a room:
        every machine in a link receives every message sent
        each machine ignores messages not intended for it

    hub
        connects multiple devices into a link
        forwards all messages to every device in the link

    switch
        keeps track of which devices are where
        only sends messages to the intended recipient

Network/Internet layer
    connects multiple links
    routers are responsible for forwarding messages from one link to another

in principle, a router can talk to any device on the network
    either directly or by forwarding to a closer router
    
    -> knowing where all 2^32 devices on the internet are is not practical,
        so we bunch them together 
        -> more on this Monday



CS 214 / 2022-04-25
===================



Internet protocol stack
-----------------------

Link layer
    Ethernet, Wifi (802.11), Bluetooth, USB, token ring, PPP, carrier pigeons
    
    connects devices within a single network
    
    Ethernet - MAC address
        scoped over a single network
        packet based
            fixed maximum packet size, variable actual size
            packets say where they are going
            

Internet layer
    IP protocol(s)
    
    communication between hosts (machines, or network cards)
        each host has a unique IP address*
            IPv4 addresses are 32-bit   
                written in "dotted quad" format
                4 numbers in the range 0-255, separated by periods
                10.1.126.5
            IPv6 addresses are 128-bit
    
    packet based
        each packet says how big it is
        each packet says which host it is intended for
        routers in the network will forward packets towards their destination
        "best effort" transmission
            -> no guarantee that packets arrive in a particular time or at all
            
    routing
        routers use "routing tables" to tell which of their peers to forward
            packets to
    
        to keep the routing table sizes manageable, IP addresses are grouped
            into subnets
        
        first attempt at grouping: class-based routing
            class A network has an 8-bit prefix, 24 bits specify host within subnet
            class B network has a 16-bit prefix, 16 bits for host
            class C network has a 24-bit prefix, 8 bits for host
    
        this was too rigid, to it has been generalized to allow arbitrary prefix lengths
            this is the "subnet mask" you may have seen in your internet settings
            a particular subnet can have any length for its prefix
    
        prefixes are assigned by three non-profits that get them from ICANN
    
    not all IP addresses are used to uniquely identify hosts
        broadcast and multicast addresses
        loopback address (127.0.0.1)
        local addresses
            not uniquely assigned to a particular host
            can only be used within a link/subnet
    
    there are not enough IPv4 addresses for current use
        we could try to switch to IPv6, but no one wants to
        
        instead, we use Network Address Translation (NAT)
        a NAT is a device similar to a router that allows multiple hosts to
            share an IP address
        
        the devices "behind" the NAT appear as one host to the global internet
            each is assigned a local IP address
        
        the NAT keeps track of which connections are open and translates
            incoming packets to have the proper (local) destination address
        
        amazingly, this works pretty well
        -> we lose the peer-to-peer nature of the Internet
        -> e.g., running a server from behind a NAT is difficult
        
    
Transport layer
    TCP, UDP (also SCTP, ARP)
    
    TCP (Transmission Control Protocol) connects processes (services) running on hosts
        processes identified by host address (IP number) and 
            service name (port number)
        -> most applications will have a standard port number
        -> but in principle, any application will work with any port

    TCP is stream based
        TCP's interface is a "full-duplex" stream
            that is, two streams going in opposite directions
    
        typical interface is similar to a file or pipe
            unlike opening a file in read/write mode, the incoming and outgoing
            streams are independent

        TCP subsystem (usually in the OS) is responsible for 
            - dividing my stream into packets
            - acknowledging receipt of packets
            - resending lost packets
            - detecting that packets were received out of order
                -> incoming stream reads bytes in the order they were *sent*,
                    not necessarily the order they were received
    
        TCP is connection based
            the connection is identified by the hosts and ports of both
                sides of the connection
            -> possible to have multiple connections between two hosts

        (Even though routers live at the Internet layer, they do monitor
        TCP connections to detect lost packets and congestion and change
        their routing decisions based on it.)

    UDP (Universal Datagram Protocol)
        like IP, best-effort datagram protocol
        like TCP, messages are sent from process to process
            that is, addresses combine host and port numbers

        no connections, no acknowledgement of receipt, no streams
        
        using UDP requires you to do all the work that TCP would normally do
        -> but only if you need it
        
    SCTP (stream control transmission protocol) 
        connection based
        connects processes
        multiplexes streams (e.g., multiple streams in both directions)
        basically unused

Application layer
    HTTP, e-mail, FTP, SSH, 
    
    every application works differently
        may be built on TCP or UDP
    
    HTTP
        client-server based
        web servers wait for incoming TCP connections
        web clients (browsers) open connections and make requests
    
        communication between services (host+port)
        but we talk about URLs
            http://host.name/path/to/resource
    
    e-mail
        SMTP, POP3, IMAP
        
        here we talk about e-mail addresses
            how e-mail addresses map to hosts is usually simple, but not always
    
    DNS (domain name service)
        how come we talk about www.google.com instead of 142.250.65.164 ?
        
        DNS is a distributed database that stores information about "domains"
            domains form a hierarchy
                the dots separate the layers
            
            resources.cs.rutgers.edu
            
            each layer is potentially a new organization
        
        DNS can store many kinds of information about domains
            A - IP address associated with this domain
            MX - machine that handles SMTP requests for this domain
            WHOIS - information about who owns this domain
            AAAA - IPv6 address for this domain
    
    
    



CS 214 / 2022-04-27
===================


GCC and standards versions
--------------------------

There have been multiple standards for C over the years
	ANSI 1989 / ISO C 1990
	ISO 1999
	ISO 2011

There have been multiple versions of POSIX
	2001, 2008, and several earlier ones

GCC uses its own standard library for C
	this provides all the functions from the C and POSIX standards
	also includes some common non-standard functions
	
By default, GCC gives you a grab bag of all standard features and
	a bunch of GCC-specific extensions
	
-std=c90
-std=c99
	specifies the version of the language and libraries we want to use

We can use "feature test macros" to enable code from later standards

#define _POSIX_C_SOURCE 200112L
	-> says we want features from the 2001 POSIX standard

Creating sockets
----------------

sockets are an API that are used to communicate across networks
-> not specific to any particular network
-> very general interface

if we try to connect to a remote host/service, how do we specify
	who we are talking to?
	
	IPv4 addresses
		-> but these are hard to remember (domain names are easier)
		-> 32-bit integers (must be big-endian)

getaddrinfo()
	#include <netdb.h>
	requires POSIX 2001 or later
	
	
   int getaddrinfo(
   	const char *node,    // e.g., domain name or IP address as string
   	const char *service, // port number as a string, or service names
    const struct addrinfo *hints,
	struct addrinfo **res);

           struct addrinfo {
               int              ai_flags;
               int              ai_family;
               	// what kind of network is this?
               	// AF_INET - IPv4
               	// AF_INET6 - IPv6
               	// AF_UNSPEC - unspecified (typically IPv4 or IPv6)
               int              ai_socktype;
               	// what kind of socket? 
                // SOCK_DGRAM - datagram (e.g., UDP)
                // SOCK_STREAM - stream (e.g., TCP)
               int              ai_protocol;
               	// allows us to specify low-level protocol (usually 0)
               	
               // not used for hints
               socklen_t        ai_addrlen;
               struct sockaddr *ai_addr;
               char            *ai_canonname;
               struct addrinfo *ai_next;
           };



socket() - used to create a "socket"
	- this will represent one end of a connection (our end)
	- returns a file descriptor
	
connect() - use a particular socket to open a connection to a remote
	host
		- automatically associates the socket with an available port
		  on the local host
	- if it succeeds, we can read from and write to the file descriptor
	
	
	read() will obtain data from the remote host
	write() will send data to the remote host
	
easiest way to use these is to use the data returned by getaddrinfo()
- see sample code



connect is asymmetric:
	the remote host must be listening for incoming connection requests
	

setting up a listener (or server) is similar to connect(), but has
	more steps
	-> in particular, we must specify which service we are providing
		that is, which port are we listening to?


we use getaddrinfo() again, with a few changes
	we use NULL for the host name (because we want a socket on the
		local host)
	
	we set ai_flags = AI_PASSIVE
	
we use socket() as before
	-> we don't use connect()
	
bind() associates our socket with a specific port on the local host
	-> this fails if the port does not exist or if another process is
		using it

listen() prepares our port to receive incoming connection requests



accept() receives an incoming connection request

	int  // returns a new file descriptor for this connection
	     // or -1 if there was a problem
	accept(
		int socket,   // our server's socket
		struct sockaddr *remote_addr,  // place to write the remote
			// host's address information (or NULL if we don't care)
		socklen_t *remote_addr_len   // place to write the length
			// of the remote host's address info (or NULL)
	);

	if accept gets a connection request, it returns a new file descriptor
	corresponding to the connection
	
common strategies
	- accept one incoming connection, deal with it, repeat
	- accept incoming connection, spawn thread, repeat
	- accept many incoming connections and use select()
		-> very complicated


Using sockets
-------------



