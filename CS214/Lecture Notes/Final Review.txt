CS 214 / 2022-05-02
===================


C concepts
    - functions, control structures (if, while, for, switch etc.)
    
Objects
    - a contiguous collection of bytes that are used to store data
    - objects have an implicit type
        - how to interpret the bytes (e.g., is it an integer)
        - size/length (how many bytes are in the object)
        - "implicit" because C keeps no type information at run-time
    
    - a few "primitive" types (built-in to the language/compiler)
        - integers (including char and pointers and enums)
            integers may be signed or unsigned
                - signed integers allow negative values
            there are at least three sizes of integer:
                char, short int, long int
                int can be its own size or the same as short or long int
                may also be other non-standard sizes (long long int)
            
            character literals are just integer constants
        - floating point
            at least two sizes: float and double
            may also be others (long double)
        - functions
    
    - collection types (arrays and structs)
        - arrays are collections of some element type laid out
            contiguously
            - to refer to an array, we just need the address of its
                first element
            - we can get any other element by adding an offset to
                the address of the first element
                
                array_variable[index] 
                    <- does the offset calculation implicitly
        
        - structs collect a fixed number of elements ("fields")
            - fields are referred to by name
            - fields do not need to be of the same type
            
            - to refer to fields in a struct, we just need the address
                of the start of the struct
                - each field has a fixed offset from the start of the struct
    
            struct node {
                int data;
                struct node* next;
            }
            
we can refer to objects in a few ways
    variables directly refer to an object
        every variable refers to some object in memory
        that object stores the value of the variable
    
    global and static variables refer to objects in the "static" or "global"
        region of memory
        these cannot be created or destroyed at run-time
    
    local variables refer to objects stored in the stack
        these are collected in "stack frames" or "activation records"
            each in-progress function will have a stack frame
            stack frames are created when a function is called and destroyed
                when it returns
    
    many objects do not correspond to a variable
        objects on the heap do not have an associated variable
        explicitly created and destroyed by the programmer
        
    pointers allow for indirect reference to an object
        a pointer object contains the address of another object
        
        int *p;
            p directly refers to a pointer object
            p may indirectly refer to an integer
            by assigning to p, we can change which integer it refers to
            
            *p gives us the integer that p indirectly refers to
                the "pointee"
                
        pointer objects can also be NULL
            NULL explicitly does not point to anything
        
        pointers can also be "bad"
            an uninitialized pointer contains a random address that may
                or may not point to anything sensible
        
            there is no general way to tell whether a pointer is good or bad
            -> it is your job not to use bad pointers
            -> if you explicitly initialize all pointer variables to NULL,
                you can at least detect bad accesses
    
    heap objects are only ever referred to indirectly
        malloc() creates heap objects
        free() destroys heap object
        
array variable vs array object

    int foo[20];  // foo directly refers to an array of 20 ints
    
    int *p = malloc(20 * sizeof(int));
                // p indirectly refers to an array of 20 ints
                
    foo and p are similar in many ways
        both refer to an array
        both can be treated as pointers
            *foo is the same as foo[0]
        both can be indexed like an array
            p[0] is the same as *p
            p[i] is the sane as *(p + i)
    
    differences:
        object for foo will be in the global space or the stack
            managed by the run-time system
        the array p indirectly refers to will be on the heap
            we must explicitly use malloc() and free()
            
        during the lifetime of foo, it will always refer to the same object
            we cannot assign to foo
            foo = p;  // not allowed
            foo and &foo give you the same address (same as &foo[0])
        
        we can change the object that p points to at any time
            p = foo;  // now p and foo both refer to the same array
            
            p is the address p contains 
            &p is the address of p itself
            
        because foo is an array variable, the compiler knows how big its object
            is
            
            sizeof(foo) == 20 * sizeof(int)
            sizeof(p) is the size of a pointer
            
            
    Example: I have a linked list that stores strings
        when I call add_name(list, name), the address name contains will be
            added to the list
            
        char buffer[100];
        
        while (...) {
            read(input_fd, buffer, 100);
            
            add_name(list, buffer);
                // this only makes sense if add_name copies the data it
                // receives
        }
        
        // at some point, we need separate objects for each string/array
        
strings are not a type
    we use arrays of characters to represent strings
    a string is a char array containing at least one '\0' byte (the terminator)
    
    the length of a string is the number of chars preceding the terminator
        it will always be less than the number of bytes in the array
    
    to copy a string, we need to add space for the terminator
    
    char *copy_str(char *s)
    {
        int l = strlen(s);
        char *r = malloc(l + 1);
        memcpy(r, s, l + 1); // could also use strcpy()
        
        return r;
    }
    
    

files and streams
    in C/Unix we use "file" to represent most forms of external communication
        a file is a stream of bytes that we can read from and/or write to
    
    files can be
        - actual files stored in a file system (e.g., on disk)
        - input from the keyboard
        - output to the terminal
        - inter-process communication (e.g., pipes)
        - network connections
        - direct hardware communication (often "files" in /dev)
    
    files are referred to by number (a file descriptor)
    
    read() and write()
        specify a file descriptor, a pointer, and a maximum number of bytes
            to read or write
            
    open() and close()
        used to create/destroy file descriptors referring to the file system
        
            open(path_name, O_RDONLY);
            open(path_name, O_WRONLY|O_TRUNC|O_CREAT, mode);
    
    other ways to create file descriptors:
        socket(), accept(), pipe(), dup(), dup2()
    
    the OS keeps track of all open files
        file descriptors are a many-to-one relation with open files

fork(), wait(), and exec()

    fork duplicates the current process
        -> the only difference will be the value that fork() returns
            in the new process (child) fork returns 0
            in the old process (parent) fork returns the child's PID
    
    the parent is responsible for cleaning up the child by calling wait()
        wait will block the parent until the child terminates and
        provide information about how the child terminated
    
        if the child terminates before the parent calls wait, it becomes
            a zombie
            -> technically, every process becomes a zombie briefly
        
        if the parent terminates without calling wait, the child becomes an
            orphan
            
            -> typically, the OS will "adopt" orphans and wait for them
    
    
    exec() changes which program the process is executing
        -> the new program starts from the beginning
        -> some process-level information preserved (like open files)
        -> otherwise, the old program is lost
            -> no way to resume
            
    we can use fork() wait() and exec() to start a program and wait for it
        to finish

multithreading
    -> what if we ran multiple processes (threads) in the same shared memory?

    pthread_create() and pthread_join()

    shared memory allows for more communication between threads
        -> more efficient
        -> more possibility for interference
        
    shared mutable data requires synchronized access to avoid problems
    
    
    mutual exclusion (mutex)
        used to ensure temporary exclusive access to some shared resource
        
    condition variables
        -> allow threads to wait for a signal from another thread
    barriers
        -> allow multiple threads to wait until a certain number of threads
            are waiting
    semaphores
        -> generalization of mutex and condition variables
        
    deadlock
        -> mutual exclusion
        -> hold and wait
        -> no preemption
        -> circular wait
        
